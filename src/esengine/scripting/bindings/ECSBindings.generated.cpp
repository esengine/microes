/**
 * @file    ECSBindings.generated.cpp
 * @brief   Auto-generated QuickJS bindings for Native platform
 * @details Generated by tools/generate_bindings.py - DO NOT EDIT MANUALLY
 *
 * @author  ESEngine Binding Generator
 * @date    2026
 */

#ifdef ES_SCRIPTING_ENABLED

#include "ECSBindings.hpp"
#include "../../ecs/Registry.hpp"
#include "../../math/Math.hpp"

#include "../../ecs/components/Camera.hpp"
#include "../../ecs/components/Hierarchy.hpp"
#include "../../ecs/components/Sprite.hpp"
#include "../../ecs/components/Transform.hpp"
#include "../../ecs/components/Velocity.hpp"

namespace esengine::scripting {

// Global registry pointer for C callbacks
static ecs::Registry* g_registry = nullptr;

// =============================================================================
// Type Conversion Helpers
// =============================================================================

static glm::vec3 jsToVec3(JSContext* ctx, JSValue jsObj) {
    glm::vec3 result(0.0f);
    JSValue x = JS_GetPropertyStr(ctx, jsObj, "x");
    JSValue y = JS_GetPropertyStr(ctx, jsObj, "y");
    JSValue z = JS_GetPropertyStr(ctx, jsObj, "z");
    double dx, dy, dz;
    JS_ToFloat64(ctx, &dx, x);
    JS_ToFloat64(ctx, &dy, y);
    JS_ToFloat64(ctx, &dz, z);
    result.x = static_cast<f32>(dx);
    result.y = static_cast<f32>(dy);
    result.z = static_cast<f32>(dz);
    JS_FreeValue(ctx, x);
    JS_FreeValue(ctx, y);
    JS_FreeValue(ctx, z);
    return result;
}

static JSValue vec3ToJS(JSContext* ctx, const glm::vec3& vec) {
    JSValue obj = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, obj, "x", JS_NewFloat64(ctx, vec.x));
    JS_SetPropertyStr(ctx, obj, "y", JS_NewFloat64(ctx, vec.y));
    JS_SetPropertyStr(ctx, obj, "z", JS_NewFloat64(ctx, vec.z));
    return obj;
}

static glm::quat jsToQuat(JSContext* ctx, JSValue jsObj) {
    glm::quat result(1.0f, 0.0f, 0.0f, 0.0f);
    JSValue w = JS_GetPropertyStr(ctx, jsObj, "w");
    JSValue x = JS_GetPropertyStr(ctx, jsObj, "x");
    JSValue y = JS_GetPropertyStr(ctx, jsObj, "y");
    JSValue z = JS_GetPropertyStr(ctx, jsObj, "z");
    double dw, dx, dy, dz;
    JS_ToFloat64(ctx, &dw, w);
    JS_ToFloat64(ctx, &dx, x);
    JS_ToFloat64(ctx, &dy, y);
    JS_ToFloat64(ctx, &dz, z);
    result.w = static_cast<f32>(dw);
    result.x = static_cast<f32>(dx);
    result.y = static_cast<f32>(dy);
    result.z = static_cast<f32>(dz);
    JS_FreeValue(ctx, w);
    JS_FreeValue(ctx, x);
    JS_FreeValue(ctx, y);
    JS_FreeValue(ctx, z);
    return result;
}

static JSValue quatToJS(JSContext* ctx, const glm::quat& quat) {
    JSValue obj = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, obj, "w", JS_NewFloat64(ctx, quat.w));
    JS_SetPropertyStr(ctx, obj, "x", JS_NewFloat64(ctx, quat.x));
    JS_SetPropertyStr(ctx, obj, "y", JS_NewFloat64(ctx, quat.y));
    JS_SetPropertyStr(ctx, obj, "z", JS_NewFloat64(ctx, quat.z));
    return obj;
}

// =============================================================================
// Camera Component Bindings
// =============================================================================

static JSValue js_Registry_getCamera(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    if (!g_registry->has<esengine::ecs::Camera>(entity)) {
        return JS_ThrowReferenceError(ctx, "Entity does not have Camera component");
    }
    auto& comp = g_registry->get<esengine::ecs::Camera>(entity);
    JSValue obj = JS_NewObject(ctx);
    // TODO: Add converter for ProjectionType
    JS_SetPropertyStr(ctx, obj, "fov", JS_NewFloat64(ctx, comp.fov));
    JS_SetPropertyStr(ctx, obj, "orthoSize", JS_NewFloat64(ctx, comp.orthoSize));
    JS_SetPropertyStr(ctx, obj, "nearPlane", JS_NewFloat64(ctx, comp.nearPlane));
    JS_SetPropertyStr(ctx, obj, "farPlane", JS_NewFloat64(ctx, comp.farPlane));
    JS_SetPropertyStr(ctx, obj, "aspectRatio", JS_NewFloat64(ctx, comp.aspectRatio));
    // TODO: Add converter for bool
    // TODO: Add converter for i32
    return obj;
}

static JSValue js_Registry_addCamera(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    esengine::ecs::Camera comp;
    JSValue projectionTypeVal = JS_GetPropertyStr(ctx, argv[1], "projectionType");
    JS_FreeValue(ctx, projectionTypeVal);
    JSValue fovVal = JS_GetPropertyStr(ctx, argv[1], "fov");
    double dfov;
    JS_ToFloat64(ctx, &dfov, fovVal);
    comp.fov = static_cast<f32>(dfov);
    JS_FreeValue(ctx, fovVal);
    JSValue orthoSizeVal = JS_GetPropertyStr(ctx, argv[1], "orthoSize");
    double dorthoSize;
    JS_ToFloat64(ctx, &dorthoSize, orthoSizeVal);
    comp.orthoSize = static_cast<f32>(dorthoSize);
    JS_FreeValue(ctx, orthoSizeVal);
    JSValue nearPlaneVal = JS_GetPropertyStr(ctx, argv[1], "nearPlane");
    double dnearPlane;
    JS_ToFloat64(ctx, &dnearPlane, nearPlaneVal);
    comp.nearPlane = static_cast<f32>(dnearPlane);
    JS_FreeValue(ctx, nearPlaneVal);
    JSValue farPlaneVal = JS_GetPropertyStr(ctx, argv[1], "farPlane");
    double dfarPlane;
    JS_ToFloat64(ctx, &dfarPlane, farPlaneVal);
    comp.farPlane = static_cast<f32>(dfarPlane);
    JS_FreeValue(ctx, farPlaneVal);
    JSValue aspectRatioVal = JS_GetPropertyStr(ctx, argv[1], "aspectRatio");
    double daspectRatio;
    JS_ToFloat64(ctx, &daspectRatio, aspectRatioVal);
    comp.aspectRatio = static_cast<f32>(daspectRatio);
    JS_FreeValue(ctx, aspectRatioVal);
    JSValue isActiveVal = JS_GetPropertyStr(ctx, argv[1], "isActive");
    JS_FreeValue(ctx, isActiveVal);
    JSValue priorityVal = JS_GetPropertyStr(ctx, argv[1], "priority");
    JS_FreeValue(ctx, priorityVal);
    g_registry->emplaceOrReplace<esengine::ecs::Camera>(entity, comp);
    return JS_UNDEFINED;
}

// =============================================================================
// Parent Component Bindings
// =============================================================================

static JSValue js_Registry_getParent(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    if (!g_registry->has<esengine::ecs::Parent>(entity)) {
        return JS_ThrowReferenceError(ctx, "Entity does not have Parent component");
    }
    auto& comp = g_registry->get<esengine::ecs::Parent>(entity);
    JSValue obj = JS_NewObject(ctx);
    // TODO: Add converter for Entity
    return obj;
}

static JSValue js_Registry_addParent(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    esengine::ecs::Parent comp;
    JSValue entityVal = JS_GetPropertyStr(ctx, argv[1], "entity");
    JS_FreeValue(ctx, entityVal);
    g_registry->emplaceOrReplace<esengine::ecs::Parent>(entity, comp);
    return JS_UNDEFINED;
}

// =============================================================================
// Children Component Bindings
// =============================================================================

static JSValue js_Registry_getChildren(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    if (!g_registry->has<esengine::ecs::Children>(entity)) {
        return JS_ThrowReferenceError(ctx, "Entity does not have Children component");
    }
    auto& comp = g_registry->get<esengine::ecs::Children>(entity);
    JSValue obj = JS_NewObject(ctx);
    return obj;
}

static JSValue js_Registry_addChildren(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    esengine::ecs::Children comp;
    g_registry->emplaceOrReplace<esengine::ecs::Children>(entity, comp);
    return JS_UNDEFINED;
}

// =============================================================================
// Sprite Component Bindings
// =============================================================================

static JSValue js_Registry_getSprite(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    if (!g_registry->has<esengine::ecs::Sprite>(entity)) {
        return JS_ThrowReferenceError(ctx, "Entity does not have Sprite component");
    }
    auto& comp = g_registry->get<esengine::ecs::Sprite>(entity);
    JSValue obj = JS_NewObject(ctx);
    // TODO: Add converter for resource::TextureHandle
    // TODO: Add converter for glm::vec4
    // TODO: Add converter for glm::vec2
    // TODO: Add converter for glm::vec2
    // TODO: Add converter for glm::vec2
    // TODO: Add converter for i32
    // TODO: Add converter for bool
    // TODO: Add converter for bool
    return obj;
}

static JSValue js_Registry_addSprite(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    esengine::ecs::Sprite comp;
    JSValue textureVal = JS_GetPropertyStr(ctx, argv[1], "texture");
    JS_FreeValue(ctx, textureVal);
    JSValue colorVal = JS_GetPropertyStr(ctx, argv[1], "color");
    JS_FreeValue(ctx, colorVal);
    JSValue sizeVal = JS_GetPropertyStr(ctx, argv[1], "size");
    JS_FreeValue(ctx, sizeVal);
    JSValue uvOffsetVal = JS_GetPropertyStr(ctx, argv[1], "uvOffset");
    JS_FreeValue(ctx, uvOffsetVal);
    JSValue uvScaleVal = JS_GetPropertyStr(ctx, argv[1], "uvScale");
    JS_FreeValue(ctx, uvScaleVal);
    JSValue layerVal = JS_GetPropertyStr(ctx, argv[1], "layer");
    JS_FreeValue(ctx, layerVal);
    JSValue flipXVal = JS_GetPropertyStr(ctx, argv[1], "flipX");
    JS_FreeValue(ctx, flipXVal);
    JSValue flipYVal = JS_GetPropertyStr(ctx, argv[1], "flipY");
    JS_FreeValue(ctx, flipYVal);
    g_registry->emplaceOrReplace<esengine::ecs::Sprite>(entity, comp);
    return JS_UNDEFINED;
}

// =============================================================================
// LocalTransform Component Bindings
// =============================================================================

static JSValue js_Registry_getLocalTransform(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    if (!g_registry->has<esengine::ecs::LocalTransform>(entity)) {
        return JS_ThrowReferenceError(ctx, "Entity does not have LocalTransform component");
    }
    auto& comp = g_registry->get<esengine::ecs::LocalTransform>(entity);
    JSValue obj = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, obj, "position", vec3ToJS(ctx, comp.position));
    JS_SetPropertyStr(ctx, obj, "rotation", quatToJS(ctx, comp.rotation));
    JS_SetPropertyStr(ctx, obj, "scale", vec3ToJS(ctx, comp.scale));
    // TODO: Add converter for glm::mat4
    JS_SetPropertyStr(ctx, obj, "position", vec3ToJS(ctx, comp.position));
    JS_SetPropertyStr(ctx, obj, "rotation", quatToJS(ctx, comp.rotation));
    JS_SetPropertyStr(ctx, obj, "scale", vec3ToJS(ctx, comp.scale));
    return obj;
}

static JSValue js_Registry_addLocalTransform(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    esengine::ecs::LocalTransform comp;
    JSValue positionVal = JS_GetPropertyStr(ctx, argv[1], "position");
    comp.position = jsToVec3(ctx, positionVal);
    JS_FreeValue(ctx, positionVal);
    JSValue rotationVal = JS_GetPropertyStr(ctx, argv[1], "rotation");
    comp.rotation = jsToQuat(ctx, rotationVal);
    JS_FreeValue(ctx, rotationVal);
    JSValue scaleVal = JS_GetPropertyStr(ctx, argv[1], "scale");
    comp.scale = jsToVec3(ctx, scaleVal);
    JS_FreeValue(ctx, scaleVal);
    JSValue matrixVal = JS_GetPropertyStr(ctx, argv[1], "matrix");
    JS_FreeValue(ctx, matrixVal);
    JSValue positionVal = JS_GetPropertyStr(ctx, argv[1], "position");
    comp.position = jsToVec3(ctx, positionVal);
    JS_FreeValue(ctx, positionVal);
    JSValue rotationVal = JS_GetPropertyStr(ctx, argv[1], "rotation");
    comp.rotation = jsToQuat(ctx, rotationVal);
    JS_FreeValue(ctx, rotationVal);
    JSValue scaleVal = JS_GetPropertyStr(ctx, argv[1], "scale");
    comp.scale = jsToVec3(ctx, scaleVal);
    JS_FreeValue(ctx, scaleVal);
    g_registry->emplaceOrReplace<esengine::ecs::LocalTransform>(entity, comp);
    return JS_UNDEFINED;
}

// =============================================================================
// WorldTransform Component Bindings
// =============================================================================

static JSValue js_Registry_getWorldTransform(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    if (!g_registry->has<esengine::ecs::WorldTransform>(entity)) {
        return JS_ThrowReferenceError(ctx, "Entity does not have WorldTransform component");
    }
    auto& comp = g_registry->get<esengine::ecs::WorldTransform>(entity);
    JSValue obj = JS_NewObject(ctx);
    // TODO: Add converter for glm::mat4
    JS_SetPropertyStr(ctx, obj, "position", vec3ToJS(ctx, comp.position));
    JS_SetPropertyStr(ctx, obj, "rotation", quatToJS(ctx, comp.rotation));
    JS_SetPropertyStr(ctx, obj, "scale", vec3ToJS(ctx, comp.scale));
    return obj;
}

static JSValue js_Registry_addWorldTransform(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    esengine::ecs::WorldTransform comp;
    JSValue matrixVal = JS_GetPropertyStr(ctx, argv[1], "matrix");
    JS_FreeValue(ctx, matrixVal);
    JSValue positionVal = JS_GetPropertyStr(ctx, argv[1], "position");
    comp.position = jsToVec3(ctx, positionVal);
    JS_FreeValue(ctx, positionVal);
    JSValue rotationVal = JS_GetPropertyStr(ctx, argv[1], "rotation");
    comp.rotation = jsToQuat(ctx, rotationVal);
    JS_FreeValue(ctx, rotationVal);
    JSValue scaleVal = JS_GetPropertyStr(ctx, argv[1], "scale");
    comp.scale = jsToVec3(ctx, scaleVal);
    JS_FreeValue(ctx, scaleVal);
    g_registry->emplaceOrReplace<esengine::ecs::WorldTransform>(entity, comp);
    return JS_UNDEFINED;
}

// =============================================================================
// Velocity Component Bindings
// =============================================================================

static JSValue js_Registry_getVelocity(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    if (!g_registry->has<esengine::ecs::Velocity>(entity)) {
        return JS_ThrowReferenceError(ctx, "Entity does not have Velocity component");
    }
    auto& comp = g_registry->get<esengine::ecs::Velocity>(entity);
    JSValue obj = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, obj, "linear", vec3ToJS(ctx, comp.linear));
    JS_SetPropertyStr(ctx, obj, "angular", vec3ToJS(ctx, comp.angular));
    return obj;
}

static JSValue js_Registry_addVelocity(JSContext* ctx, JSValueConst this_val, int argc, JSValueConst* argv) {
    u32 entity;
    JS_ToUint32(ctx, &entity, argv[0]);
    esengine::ecs::Velocity comp;
    JSValue linearVal = JS_GetPropertyStr(ctx, argv[1], "linear");
    comp.linear = jsToVec3(ctx, linearVal);
    JS_FreeValue(ctx, linearVal);
    JSValue angularVal = JS_GetPropertyStr(ctx, argv[1], "angular");
    comp.angular = jsToVec3(ctx, angularVal);
    JS_FreeValue(ctx, angularVal);
    g_registry->emplaceOrReplace<esengine::ecs::Velocity>(entity, comp);
    return JS_UNDEFINED;
}

// =============================================================================
// Main Binding Function
// =============================================================================

void bindECS(ScriptContext& ctx, ecs::Registry& registry) {
    g_registry = &registry;
    JSContext* jsCtx = ctx.getJSContext();
    JSValue global = JS_GetGlobalObject(jsCtx);
    JSValue registryObj = JS_NewObject(jsCtx);

    // Entity management
    JS_SetPropertyStr(jsCtx, registryObj, "create",
                     JS_NewCFunction(jsCtx, js_Registry_create, "create", 0));
    JS_SetPropertyStr(jsCtx, registryObj, "destroy",
                     JS_NewCFunction(jsCtx, js_Registry_destroy, "destroy", 1));
    JS_SetPropertyStr(jsCtx, registryObj, "valid",
                     JS_NewCFunction(jsCtx, js_Registry_valid, "valid", 1));

    // Camera component
    JS_SetPropertyStr(jsCtx, registryObj, "getCamera",
                     JS_NewCFunction(jsCtx, js_Registry_getCamera, "getCamera", 1));
    JS_SetPropertyStr(jsCtx, registryObj, "addCamera",
                     JS_NewCFunction(jsCtx, js_Registry_addCamera, "addCamera", 2));

    // Parent component
    JS_SetPropertyStr(jsCtx, registryObj, "getParent",
                     JS_NewCFunction(jsCtx, js_Registry_getParent, "getParent", 1));
    JS_SetPropertyStr(jsCtx, registryObj, "addParent",
                     JS_NewCFunction(jsCtx, js_Registry_addParent, "addParent", 2));

    // Children component
    JS_SetPropertyStr(jsCtx, registryObj, "getChildren",
                     JS_NewCFunction(jsCtx, js_Registry_getChildren, "getChildren", 1));
    JS_SetPropertyStr(jsCtx, registryObj, "addChildren",
                     JS_NewCFunction(jsCtx, js_Registry_addChildren, "addChildren", 2));

    // Sprite component
    JS_SetPropertyStr(jsCtx, registryObj, "getSprite",
                     JS_NewCFunction(jsCtx, js_Registry_getSprite, "getSprite", 1));
    JS_SetPropertyStr(jsCtx, registryObj, "addSprite",
                     JS_NewCFunction(jsCtx, js_Registry_addSprite, "addSprite", 2));

    // LocalTransform component
    JS_SetPropertyStr(jsCtx, registryObj, "getLocalTransform",
                     JS_NewCFunction(jsCtx, js_Registry_getLocalTransform, "getLocalTransform", 1));
    JS_SetPropertyStr(jsCtx, registryObj, "addLocalTransform",
                     JS_NewCFunction(jsCtx, js_Registry_addLocalTransform, "addLocalTransform", 2));

    // WorldTransform component
    JS_SetPropertyStr(jsCtx, registryObj, "getWorldTransform",
                     JS_NewCFunction(jsCtx, js_Registry_getWorldTransform, "getWorldTransform", 1));
    JS_SetPropertyStr(jsCtx, registryObj, "addWorldTransform",
                     JS_NewCFunction(jsCtx, js_Registry_addWorldTransform, "addWorldTransform", 2));

    // Velocity component
    JS_SetPropertyStr(jsCtx, registryObj, "getVelocity",
                     JS_NewCFunction(jsCtx, js_Registry_getVelocity, "getVelocity", 1));
    JS_SetPropertyStr(jsCtx, registryObj, "addVelocity",
                     JS_NewCFunction(jsCtx, js_Registry_addVelocity, "addVelocity", 2));

    JS_SetPropertyStr(jsCtx, global, "Registry", registryObj);
    JS_FreeValue(jsCtx, global);
}


}  // namespace esengine::scripting

#endif  // ES_SCRIPTING_ENABLED
