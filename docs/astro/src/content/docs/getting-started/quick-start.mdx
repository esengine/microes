---
title: Quick Start
description: Create your first ESEngine game in minutes
---

import { Steps, Aside } from '@astrojs/starlight/components';

Let's create a simple game that displays a moving sprite. This will introduce you to the core concepts of ESEngine.

## Create a New Project

<Steps>

1. **Create your game directory**

   ```bash
   mkdir my-game
   cd my-game
   ```

2. **Create CMakeLists.txt**

   ```cmake
   cmake_minimum_required(VERSION 3.16)
   project(MyGame)

   # Find ESEngine (adjust path as needed)
   add_subdirectory(../esengine esengine)

   # Create executable
   add_executable(MyGame src/main.cpp)
   target_link_libraries(MyGame PRIVATE esengine)
   ```

3. **Create src/main.cpp**

   ```cpp
   #include <esengine/ESEngine.hpp>

   using namespace esengine;
   using namespace esengine::ecs;

   // Components
   struct Position {
       float x, y;
   };

   struct Velocity {
       float vx, vy;
   };

   class MyGame : public Application {
   public:
       MyGame() : Application({.title = "My First Game", .width = 800, .height = 600}) {}

   protected:
       void onInit() override {
           // Create a player entity
           Entity player = getRegistry().create();
           getRegistry().emplace<Position>(player, 400.0f, 300.0f);
           getRegistry().emplace<Velocity>(player, 100.0f, 50.0f);
       }

       void onUpdate(float dt) override {
           // Update all entities with Position and Velocity
           auto view = getRegistry().view<Position, Velocity>();
           for (auto [entity, pos, vel] : view.each()) {
               pos.x += vel.vx * dt;
               pos.y += vel.vy * dt;

               // Bounce off edges
               if (pos.x < 0 || pos.x > 800) vel.vx *= -1;
               if (pos.y < 0 || pos.y > 600) vel.vy *= -1;
           }
       }

       void onRender() override {
           // Draw entities (simplified - actual rendering uses Renderer API)
           auto view = getRegistry().view<Position>();
           for (auto [entity, pos] : view.each()) {
               // renderer.drawRect(pos.x - 25, pos.y - 25, 50, 50, Color::Red);
           }
       }
   };

   ES_MAIN(MyGame)
   ```

</Steps>

## Build and Run

### Native (for quick testing)

```bash
cmake -B build
cmake --build build
./build/MyGame
```

### Web

```bash
emcmake cmake -B build_web -DES_BUILD_WEB=ON
cmake --build build_web

# Serve the output
npx serve build_web
# Open http://localhost:3000/MyGame.html
```

<Aside type="tip">
  Use native builds for fast iteration during development, then test on web periodically.
</Aside>

## Understanding the Code

### Application Lifecycle

```
┌─────────────┐
│ Constructor │
└──────┬──────┘
       ▼
┌─────────────┐
│   onInit()  │ ← Load assets, create entities
└──────┬──────┘
       ▼
┌─────────────┐
│  Main Loop  │ ◄─────────────────┐
│  ┌────────┐ │                   │
│  │onUpdate│ │ ← Game logic      │
│  └────────┘ │                   │
│  ┌────────┐ │                   │
│  │onRender│ │ ← Draw frame      │
│  └────────┘ │                   │
└──────┬──────┘                   │
       │ (running)                │
       └──────────────────────────┘
       │ (quit)
       ▼
┌─────────────┐
│ onShutdown()│ ← Cleanup
└─────────────┘
```

### ECS Basics

ESEngine uses an Entity-Component-System architecture:

- **Entity**: A unique identifier (just a number)
- **Component**: Plain data structs attached to entities
- **System**: Logic that operates on entities with specific components

```cpp
// Create entity
Entity e = registry.create();

// Add components
registry.emplace<Position>(e, 0.0f, 0.0f);
registry.emplace<Velocity>(e, 1.0f, 0.0f);

// Query and iterate
for (auto [entity, pos, vel] : registry.view<Position, Velocity>().each()) {
    pos.x += vel.vx * dt;
}
```

## Next Steps

- [Learn ECS in depth](/microes/guides/ecs/)
- [Add sprites and textures](/microes/guides/rendering/)
- [Handle input](/microes/guides/input/)
