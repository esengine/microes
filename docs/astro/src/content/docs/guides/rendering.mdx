---
title: Rendering
description: Camera, transform, and render order in ESEngine
---

import { Aside } from '@astrojs/starlight/components';

ESEngine uses a component-based rendering system. Add rendering components to entities in the scene editor and the C++ backend handles drawing automatically.

For detailed guides on specific rendering components, see [Sprite](/microes/guides/sprite/) and [Spine Animation](/microes/guides/spine/).

## Camera

A `Camera` component is required to see anything. The editor's default scene already includes one.

### Camera Properties

| Property | Type | Description |
|----------|------|-------------|
| `projectionType` | number | 0 = Perspective, 1 = Orthographic |
| `fov` | number | Field of view in degrees (perspective only) |
| `orthoSize` | number | Half-height in world units (orthographic only) |
| `nearPlane` | number | Near clipping plane |
| `farPlane` | number | Far clipping plane |
| `isActive` | boolean | Whether this camera is used for rendering |
| `aspectRatio` | number | Camera aspect ratio |
| `priority` | number | Higher priority camera takes precedence |
| `showFrustum` | boolean | Draw the camera frustum wireframe in the editor |

### Orthographic Camera

Best for 2D games. The `orthoSize` determines how much of the world is visible. Set `projectionType` to `1` in the inspector.

### Canvas Integration

For screen adaptation and resolution scaling, attach a `Canvas` component to the camera entity. See [Canvas & Resolution](/microes/guides/canvas/) for setup and scale modes.

### Moving the Camera

Query the camera entity and modify its transform:

```typescript
import { defineSystem, addSystem, Res, Input, Query, Mut, LocalTransform, Camera } from 'esengine';

addSystem(defineSystem(
    [Res(Input), Query(Mut(LocalTransform), Camera)],
    (input, query) => {
        for (const [entity, transform, camera] of query) {
            if (input.isKeyDown('ArrowLeft')) {
                transform.position.x -= 5;
            }
            if (input.isKeyDown('ArrowRight')) {
                transform.position.x += 5;
            }
        }
    }
));
```

## Transform

Every visible entity needs a `LocalTransform`. Add it to entities in the scene editor and configure position, rotation, and scale in the inspector.

### Rotation

Rotation uses quaternions. For 2D rotation around the Z-axis:

```typescript
import { defineSystem, addSystem, Res, Time, Query, Mut, LocalTransform, Sprite } from 'esengine';

addSystem(defineSystem(
    [Res(Time), Query(Mut(LocalTransform), Sprite)],
    (time, query) => {
        for (const [entity, transform, sprite] of query) {
            const angle = time.elapsed;
            const halfAngle = angle / 2;
            transform.rotation = {
                w: Math.cos(halfAngle),
                x: 0,
                y: 0,
                z: Math.sin(halfAngle)
            };
        }
    }
));
```

### Scale

```typescript
transform.scale = { x: 2, y: 2, z: 1 };   // Double size
transform.scale = { x: -1, y: 1, z: 1 };  // Flip horizontally
```

## Render Order

Sprites are drawn in order by:

1. **Z position** (`transform.position.z`) — lower Z draws first (behind)
2. **Layer** (`sprite.layer`) — higher layer draws on top

Set these values in the inspector when placing entities, or modify them at runtime in systems.

<Aside type="tip">
  The C++ backend handles all WebGL rendering. You just set component data and the engine draws everything automatically each frame.
</Aside>

## Next Steps

- [Canvas & Resolution](/microes/guides/canvas/) — screen adaptation and scale modes
- [Sprite](/microes/guides/sprite/) — sprite rendering and animation
- [Spine Animation](/microes/guides/spine/) — skeletal animation
- [Custom Draw](/microes/guides/custom-draw/) — immediate-mode drawing for debug visualization and dynamic graphics
- [Post-Processing](/microes/guides/post-processing/) — full-screen effects (blur, vignette, grayscale)
- [Geometry & Meshes](/microes/guides/geometry/) — custom mesh creation for advanced rendering
