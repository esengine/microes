---
title: Asset Loading
description: Loading textures, Spine data, and other assets in ESEngine
---

import { Aside } from '@astrojs/starlight/components';

ESEngine provides the `Assets` resource (an `AssetServer` instance) for loading textures, Spine animations, materials, and generic files. Access it in any system via `Res(Assets)`.

## Accessing Assets

```typescript
import { defineSystem, addStartupSystem, Res } from 'esengine';
import { Assets } from 'esengine';

addStartupSystem(defineSystem(
    [Res(Assets)],
    async (assets) => {
        const tex = await assets.loadTexture('assets/player.png');
        console.log(`Loaded ${tex.width}x${tex.height}, handle: ${tex.handle}`);
    }
));
```

## Texture Loading

### loadTexture(path)

Loads an image and returns a `TextureInfo` object. The image is automatically flipped vertically for OpenGL UV conventions.

```typescript
const tex = await assets.loadTexture('assets/player.png');
sprite.texture = tex.handle;
```

**Returns:** `TextureInfo { handle: TextureHandle, width: number, height: number }`

### Other Texture Methods

| Method | Description |
|--------|-------------|
| `getTexture(path)` | Returns cached `TextureInfo` if already loaded, `undefined` otherwise |
| `hasTexture(path)` | Returns `true` if the texture is cached |
| `releaseTexture(path)` | Releases the texture from GPU memory and cache |
| `releaseAll()` | Releases all cached assets |

### 9-Slice Metadata

For 9-slice sprites, set border metadata after loading:

```typescript
const tex = await assets.loadTexture('assets/panel.png');
assets.setTextureMetadata(tex.handle, {
    left: 10, right: 10, top: 10, bottom: 10
});
```

## Spine Loading

```typescript
const result = await assets.loadSpine('assets/hero.json', 'assets/hero.atlas');
if (!result.success) {
    console.error(result.error);
}
```

`loadSpine` automatically:
1. Fetches the atlas file and writes it to the virtual filesystem
2. Parses the atlas for texture filenames and loads each texture
3. Fetches the skeleton file (`.json` or `.skel` binary) and writes it to the virtual filesystem

| Method | Description |
|--------|-------------|
| `loadSpine(skeleton, atlas, baseUrl?)` | Load Spine skeleton and atlas |
| `isSpineLoaded(skeleton, atlas)` | Check if a Spine asset pair is already loaded |

## BitmapFont Loading

```typescript
const fontHandle = await assets.loadBitmapFont('assets/my-font.fnt');
```

Supports `.fnt` (BMFont text format) and `.bmfont` (JSON metadata) files. The loader automatically resolves and loads referenced texture atlases.

| Method | Returns | Description |
|--------|---------|-------------|
| `loadBitmapFont(path)` | `Promise<number>` | Load a bitmap font file and its textures. Returns a font handle |
| `getFont(path)` | `number \| undefined` | Get cached font handle, `undefined` if not loaded |
| `releaseFont(path)` | `void` | Release the font and its textures from memory |

## Prefab Loading

```typescript
const prefab = await assets.loadPrefab('prefabs/Enemy.esprefab');
```

Loads and parses a `.esprefab` file. The result is a `PrefabData` object that can be passed to `instantiatePrefab()`.

| Method | Returns | Description |
|--------|---------|-------------|
| `loadPrefab(path, baseUrl?)` | `Promise<PrefabData>` | Load and cache a prefab file |

See [Prefabs](/microes/guides/prefabs/) for the full prefab API.

## Generic File Loading

| Method | Returns | Description |
|--------|---------|-------------|
| `loadJson<T>(path, options?)` | `Promise<T>` | Load and parse a JSON file |
| `loadText(path, options?)` | `Promise<string>` | Load a text file |
| `loadBinary(path, options?)` | `Promise<ArrayBuffer>` | Load a binary file |

```typescript
const config = await assets.loadJson<GameConfig>('assets/config.json');
const csv = await assets.loadText('assets/levels.csv');
const data = await assets.loadBinary('assets/tilemap.bin');
```

### FileLoadOptions

| Option | Type | Description |
|--------|------|-------------|
| `baseUrl` | string | Override the base URL for this request |
| `noCache` | boolean | Skip cache — always fetch from network |

## Batch Loading

Load all assets from an `AddressableManifest` in parallel with `loadAll`:

```typescript
const manifest = await assets.loadJson('assets/addressable-manifest.json');
assets.setAddressableManifest(manifest);

const bundle = await assets.loadAll(manifest);

// Access loaded assets from the bundle
const bgTex = bundle.textures.get('bg');
const config = bundle.json.get('game-config');
```

You can also load a subset of assets by label or group:

```typescript
const bundle = await assets.loadByLabel('ui-sprites');
const levelBundle = await assets.loadGroup('level-1');
```

### AssetBundle

The returned `AssetBundle` contains Maps keyed by address (or path if no address is set):

| Field | Type |
|-------|------|
| `textures` | `Map<string, TextureInfo>` |
| `materials` | `Map<string, LoadedMaterial>` |
| `spine` | `Map<string, SpineLoadResult>` |
| `fonts` | `Map<string, FontHandle>` |
| `prefabs` | `Map<string, PrefabData>` |
| `json` | `Map<string, unknown>` |
| `text` | `Map<string, string>` |
| `binary` | `Map<string, ArrayBuffer>` |

## Material Loading

```typescript
const loaded = await assets.loadMaterial('assets/effects/glow.esmaterial');
sprite.material = loaded.handle;
```

See [Materials & Shaders](/microes/guides/materials/) for the full material API and `.esmaterial` file format.

## Caching

All load methods cache by path. Loading the same path twice returns the cached result without a network request. Use the `noCache` option on generic file loaders to bypass caching:

```typescript
const fresh = await assets.loadJson('assets/config.json', { noCache: true });
```

## Base URL

Set `assets.baseUrl` to prefix all relative paths:

```typescript
assets.baseUrl = 'https://cdn.example.com/game';
const tex = await assets.loadTexture('sprites/player.png');
// fetches https://cdn.example.com/game/sprites/player.png
```

Absolute paths and full URLs are not affected by `baseUrl`.

## Embedded Assets

For Playable Ad builds, the editor's build pipeline automatically embeds all referenced assets as data URIs into the output bundle. At runtime, `assets.loadTexture()` / `assets.loadJson()` and other load calls resolve from the embedded data instead of fetching over the network — no code changes are needed.

## Addressable Assets

Addressable assets let you load resources by logical address, label, or group instead of raw file paths. The editor builds an `AddressableManifest` during the build process, which maps addresses and labels to asset paths.

### Loading by Address

```typescript
const texture = await assets.load('player-idle');
```

### Loading by Label

Load all assets tagged with a label. Returns an `AssetBundle`:

```typescript
const bundle = await assets.loadByLabel('ui-sprites');
for (const [path, tex] of bundle.textures) {
    console.log(`Loaded ${path}: ${tex.width}x${tex.height}`);
}
```

### Loading by Group

Load all assets in a named group:

```typescript
const bundle = await assets.loadGroup('level-1');
```

### Setting the Manifest

The manifest is generated by the editor during build. At runtime, set it before loading:

```typescript
import { Assets } from 'esengine';

const manifest = await assets.loadJson('assets/addressable-manifest.json');
assets.setAddressableManifest(manifest);
```

### Manifest Format

The `AddressableManifest` has the following structure:

```typescript
interface AddressableManifest {
    version: '2.0';
    groups: Record<string, AddressableManifestGroup>;
}

interface AddressableManifestGroup {
    bundleMode: string;
    labels: string[];
    assets: Record<string, AddressableManifestAsset>;
}

interface AddressableManifestAsset {
    path: string;
    address?: string;
    type: AddressableAssetType;
    size: number;
    labels: string[];
    metadata?: {
        atlas?: string;
        atlasPage?: number;
        atlasFrame?: { x: number; y: number; width: number; height: number };
    };
}
```

Each group contains assets with their paths, optional addresses, labels, and type-specific metadata. Asset types include `texture`, `material`, `spine`, `bitmap-font`, `prefab`, `json`, `text`, `binary`, and `audio`.

<Aside type="note">
  Addressable addresses, labels, and groups are configured in the editor's Addressable panel. The manifest is generated automatically during build.
</Aside>

## Next Steps

- [Materials & Shaders](/microes/guides/materials/) — custom shaders and blend modes
- [Sprite](/microes/guides/sprite/) — using textures with sprites
- [Bitmap Text](/microes/guides/bitmap-text/) — rendering text with bitmap fonts
- [Spine Animation](/microes/guides/spine/) — Spine skeletal animation
