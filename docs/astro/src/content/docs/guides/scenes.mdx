---
title: Scenes
description: Creating, loading, and querying scenes in ESEngine
---

import { Aside } from '@astrojs/starlight/components';

A **scene** is a collection of entities, components, and parent-child relationships. You create scenes visually in the ESEngine editor, and they are saved as JSON files. At runtime, the engine loads the scene and spawns all entities with their configured components.

## Scene Structure

A scene file contains:

- **Entities** — each with a unique ID and a name
- **Components** — data attached to each entity (transforms, sprites, colliders, etc.)
- **Hierarchy** — parent-child relationships between entities

```json
{
  "version": "1.0",
  "name": "Level1",
  "entities": [
    {
      "id": 1,
      "name": "Player",
      "parent": null,
      "children": [2],
      "components": [
        { "type": "LocalTransform", "data": { "position": { "x": 0, "y": 0, "z": 0 } } },
        { "type": "Sprite", "data": { "texture": "player.png", "size": { "x": 32, "y": 32 } } }
      ]
    }
  ]
}
```

## Loading Scenes

In the editor, scenes are loaded automatically — you only write scripts that define components and systems.

After building your project, the runtime loader handles scene loading:

```typescript
import { loadSceneWithAssets, type SceneData } from 'esengine';

const sceneData: SceneData = await fetch('/scene.json').then(r => r.json());
const entityMap = await loadSceneWithAssets(world, sceneData, { assetServer });
```

<Aside type="tip">
  `loadSceneWithAssets` automatically loads textures, materials, and Spine assets referenced in the scene. Use `loadSceneData` if you don't need asset loading.
</Aside>

## Finding Entities

### By Name

Every entity loaded from a scene receives a built-in `Name` component with the name assigned in the editor. Use `findEntityByName` to look up entities:

```typescript
import { findEntityByName } from 'esengine';

const player = findEntityByName(world, 'Player');
if (player !== null) {
    const transform = world.get(player, LocalTransform);
}
```

### By Component or Tag

Use `getEntitiesWithComponents` or a `Query` to find entities by their components:

```typescript
import { defineTag, Query, Mut, LocalTransform } from 'esengine';

const Player = defineTag('Player');

// Direct lookup
const players = world.getEntitiesWithComponents([Player]);

// In a system
addSystem(defineSystem(
    [Query(Mut(LocalTransform), Player)],
    (query) => {
        for (const [entity, transform] of query) {
            // process each player
        }
    }
));
```

### Traversing the Hierarchy

Use the `Parent` and `Children` components to walk the entity tree:

```typescript
import { Parent, Children } from 'esengine';

const children = world.get(entity, Children);
if (children) {
    for (const child of children.entities) {
        const childTransform = world.get(child, LocalTransform);
    }
}
```

## Entity Hierarchy

Scene entities can form a tree via parent-child relationships. The engine manages `Parent` and `Children` components automatically.

```typescript
// Set parent (adds Parent component to child, updates Children on parent)
world.setParent(child, parent);

// Remove parent (child becomes a root entity)
world.removeParent(child);
```

When a parent's `LocalTransform` changes, the engine propagates the transform to all descendants via the `WorldTransform` component.

## Dynamic Entities

You can spawn and despawn entities at runtime using `Commands`:

```typescript
import { defineSystem, addSystem, Commands, LocalTransform, Sprite } from 'esengine';

addSystem(defineSystem(
    [Commands],
    (commands) => {
        // Spawn a new entity with components
        commands.spawn()
            .insert(LocalTransform, { position: { x: 100, y: 0, z: 0 }, rotation: { w: 1, x: 0, y: 0, z: 0 }, scale: { x: 1, y: 1, z: 1 } })
            .insert(Sprite, { texture: bulletTexture, color: { r: 1, g: 1, b: 1, a: 1 }, size: { x: 8, y: 8 } });

        // Despawn an entity
        commands.despawn(entity);
    }
));
```

<Aside type="note">
  Commands are buffered and applied at the end of the current schedule stage, not immediately.
</Aside>
