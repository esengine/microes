---
title: Scenes
description: Creating, loading, and querying scenes in ESEngine
---

import { Aside } from '@astrojs/starlight/components';

A **scene** is a collection of entities, components, and parent-child relationships. You create scenes visually in the ESEngine editor, and they are saved as JSON files. At runtime, the engine loads the scene and spawns all entities with their configured components.

## Scene Structure

A scene file contains:

- **Entities** — each with a unique ID and a name
- **Components** — data attached to each entity (transforms, sprites, colliders, etc.)
- **Hierarchy** — parent-child relationships between entities

```json
{
  "version": "1.0",
  "name": "Level1",
  "entities": [
    {
      "id": 1,
      "name": "Player",
      "parent": null,
      "children": [2],
      "components": [
        { "type": "LocalTransform", "data": { "position": { "x": 0, "y": 0, "z": 0 } } },
        { "type": "Sprite", "data": { "texture": "player.png", "size": { "x": 32, "y": 32 } } }
      ]
    }
  ]
}
```

## Loading Scenes

In the editor, scenes are loaded automatically — you only write scripts that define components and systems.

After building your project, the engine automatically loads the scene, resolves all referenced assets (textures, materials, Spine), and creates a default camera if none exists. You don't need to handle scene loading manually.

## Finding Entities

### By Name

Every entity loaded from a scene receives a built-in `Name` component with the name assigned in the editor. Query `Name` to find entities:

```typescript
import { defineSystem, addStartupSystem, Query, Name, LocalTransform } from 'esengine';

addStartupSystem(defineSystem(
    [Query(Name, LocalTransform)],
    (query) => {
        for (const [entity, name, transform] of query) {
            if (name.value === 'Player') {
                // found the player entity
            }
        }
    }
));
```

### By Component or Tag

Use a `Query` to find entities by their components:

```typescript
import { defineSystem, addSystem, defineTag, Query, Mut, LocalTransform } from 'esengine';

const Player = defineTag('Player');

addSystem(defineSystem(
    [Query(Mut(LocalTransform), Player)],
    (query) => {
        for (const [entity, transform] of query) {
            // process each player
        }
    }
));
```

### Traversing the Hierarchy

Use the `Children` component to walk the entity tree:

```typescript
import { defineSystem, addSystem, Query, Children, LocalTransform } from 'esengine';

addSystem(defineSystem(
    [Query(Children, LocalTransform)],
    (query) => {
        for (const [entity, children, transform] of query) {
            // children.entities contains child entity IDs
        }
    }
));
```

## Entity Hierarchy

Scene entities can form a tree via parent-child relationships. Set up parent-child relationships in the editor — the engine manages `Parent` and `Children` components automatically.

When a parent's `LocalTransform` changes, the engine propagates the transform to all descendants via the `WorldTransform` component.

## Dynamic Entities

You can spawn and despawn entities at runtime using `Commands`:

```typescript
import { defineSystem, addSystem, Commands, LocalTransform, Sprite } from 'esengine';

addSystem(defineSystem(
    [Commands()],
    (commands) => {
        // Spawn a new entity with components
        commands.spawn()
            .insert(LocalTransform, { position: { x: 100, y: 0, z: 0 }, rotation: { w: 1, x: 0, y: 0, z: 0 }, scale: { x: 1, y: 1, z: 1 } })
            .insert(Sprite, { texture: bulletTexture, color: { r: 1, g: 1, b: 1, a: 1 }, size: { x: 8, y: 8 } });

        // Despawn an entity
        commands.despawn(entity);
    }
));
```

<Aside type="note">
  Commands are buffered and applied at the end of the current schedule stage, not immediately.
</Aside>

## Entity Visibility

Entities have a `visible` property (default `true`). When set to `false` in the editor, the entity's components are skipped during scene loading — it exists in the hierarchy but has no runtime behaviour. Use this to keep reference entities in the scene file without spawning them.

## Scene Manager

The SDK provides the `SceneManager` resource and `sceneManagerPlugin` for managing the loading, switching, and lifecycle of multiple scenes. When using `createWebApp()`, the plugin is included automatically -- no manual registration needed.

```typescript
import { SceneManager } from 'esengine';

const mgr = app.getResource(SceneManager);
```

## Registering Scenes

Before the app starts, register each scene with a name, a path to its JSON file, and optional per-scene systems and lifecycle hooks:

```typescript
import { createWebApp, SceneManager, Schedule, type SceneConfig } from 'esengine';

const app = createWebApp(module);

app.registerScene({
    name: 'menu',
    path: '/scenes/menu.json',
    systems: [
        { schedule: Schedule.Update, system: menuUpdateSystem },
    ],
    setup: (ctx) => {
        ctx.registerDrawCallback('menu-particles', drawParticles);
    },
    cleanup: (ctx) => {
        // called before scene unload
    },
});

app.registerScene({ name: 'game', path: '/scenes/game.json' });
app.setInitialScene('menu');
app.run();
```

Instead of specifying a file path with `path`, you can pass scene data directly via `data`. This is useful for procedurally generated or in-memory scenes:

```typescript
app.registerScene({
    name: 'procedural',
    data: {
        version: '1.0',
        name: 'procedural',
        entities: [],
    },
    setup: (ctx) => {
        // generate entities programmatically
    },
});
```

<Aside type="tip">
  Systems registered in `systems` are automatically wrapped as scene-scoped systems and only run while that scene's status is `running`.
</Aside>

## Switching Scenes

Use `SceneManager` to switch between registered scenes. Switching unloads the current scene and loads the new one:

```typescript
const mgr = app.getResource(SceneManager);

// Simple switch (unloads old, loads new)
await mgr.switchTo('game');

// Switch with fade transition
await mgr.switchTo('game', { transition: 'fade', duration: 0.5 });

// Full transition options
await mgr.switchTo('game', {
    transition: 'fade',
    duration: 1.0,
    color: { r: 0, g: 0, b: 0, a: 1 },
    keepPersistent: true,
    onStart: () => console.log('transition started'),
    onComplete: () => console.log('transition finished'),
});
```

Full `switchTo` options:

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `transition` | `'none' \| 'fade'` | `'none'` | Transition animation type |
| `duration` | `number` | engine default | Total transition duration (seconds); fade-out and fade-in each take half |
| `color` | `Color` | engine default | Mask colour for the fade |
| `keepPersistent` | `boolean` | `true` | Whether to keep persistent entities |
| `onStart` | `() => void` | - | Callback when the transition starts |
| `onComplete` | `() => void` | - | Callback when the transition finishes |

<Aside type="note">
  Calling `switchTo` while a transition is in progress is ignored. Use `mgr.isTransitioning()` to check whether a transition is active.
</Aside>

## Multi-Scene (Additive Loading)

Load additional scenes on top of the current primary scene. This is useful for HUDs, pause menus, or overlay layers:

```typescript
const mgr = app.getResource(SceneManager);

// Load a scene on top of the current one
await mgr.loadAdditive('hud');
await mgr.loadAdditive('pause-menu');

// Unload additive scene
await mgr.unload('pause-menu');
```

<Aside type="note">
  Additive scenes run independently from the primary scene, each with its own systems and lifecycle. Unloading an additive scene does not affect the primary scene.
</Aside>

## Scene Lifecycle

Control whether a loaded scene's systems and entities are active:

```typescript
const mgr = app.getResource(SceneManager);

// Pause — systems stop, entities remain visible
mgr.pause('game');
mgr.resume('game');

// Sleep — systems stop, entities hidden
mgr.sleep('game');
mgr.wake('game');
```

| Method | Systems | Entities Visible |
|--------|---------|-----------------|
| `resume` / `wake` | Running | Yes |
| `pause` | Stopped | Yes |
| `sleep` | Stopped | No |

<Aside type="tip">
  Use `pause` for a pause menu overlay — the game world stays visible behind it. Use `sleep` to fully deactivate a scene that should not render at all.
</Aside>

## Scene Context

When a scene loads, its `setup` callback receives a `SceneContext` that provides scene-scoped operations:

```typescript
app.registerScene({
    name: 'game',
    path: '/scenes/game.json',
    setup: (ctx) => {
        // Spawn entities owned by this scene
        const e = ctx.spawn();

        // Register draw callbacks scoped to this scene
        ctx.registerDrawCallback('game-debug', drawDebug);

        // Add post-process effects scoped to this scene
        ctx.addPostProcessPass('bloom', bloomShader);

        // Mark entity as persistent (survives scene unload)
        ctx.setPersistent(e, true);
    },
});
```

Entities spawned through `SceneContext` are automatically tagged with a `SceneOwner` component and cleaned up when the scene unloads — unless marked as persistent.

### SceneOwner Component

Entities loaded from a scene file automatically get a `SceneOwner` component. Use it to check which scene owns an entity:

```typescript
import { SceneOwner } from 'esengine';

const owner = world.get(entity, SceneOwner);
console.log(owner.scene);       // 'game'
console.log(owner.persistent);  // false
```

### Scene-scoped Systems

Systems registered in a scene config only run when that scene's status is `'running'`. They are automatically wrapped so they skip execution when the scene is paused or sleeping:

```typescript
import { defineSystem, Query, Mut, LocalTransform, Schedule } from 'esengine';

const mySystem = defineSystem(
    [Query(Mut(LocalTransform))],
    (query) => {
        for (const [entity, transform] of query) {
            // runs only while 'game' scene is running
        }
    }
);

app.registerScene({
    name: 'game',
    path: '/scenes/game.json',
    systems: [{ schedule: Schedule.Update, system: mySystem }],
});
```

<Aside type="tip">
  When a scene is `paused` or `sleeping`, its scoped systems do not execute -- no need to check the scene state manually.
</Aside>

## Scene Transitions

Use the `transitionTo` helper for animated scene switches:

```typescript
import { transitionTo } from 'esengine';

// Fade to black, switch scene, fade in
await transitionTo(app, 'game', { type: 'fade', duration: 1.0 });

// Custom mask colour
await transitionTo(app, 'game', {
    type: 'fade',
    duration: 0.5,
    color: { r: 1, g: 1, b: 1, a: 1 },
});
```

`transitionTo` is a convenience wrapper around `mgr.switchTo()`. It obtains the `SceneManager` resource internally and calls `switchTo`. The process is asynchronous — the old scene fades out, the scene switch executes, then the new scene fades in.

## Querying Scene State

`SceneManager` provides a set of methods for inspecting scene status:

```typescript
const mgr = app.getResource(SceneManager);

mgr.getActive();            // current primary scene name, or null
mgr.isActive('game');       // whether a given scene is the primary scene
mgr.getActiveScenes();      // all scene names with 'running' status
mgr.getLoaded();            // all loaded scene names
mgr.isLoaded('game');       // whether the scene is loaded
mgr.isPaused('game');       // whether the scene is paused
mgr.isSleeping('game');     // whether the scene is sleeping
mgr.isTransitioning();      // whether a scene transition is in progress
mgr.getSceneStatus('game'); // detailed scene status
mgr.getScene('game');       // get the scene's SceneContext, or null if not loaded
mgr.getLoadOrder();         // scene names in load order
```

`getSceneStatus` return values:

| Status | Description |
|--------|-------------|
| `'loading'` | Scene is currently loading |
| `'running'` | Scene is running |
| `'paused'` | Scene is paused (systems stopped, entities visible) |
| `'sleeping'` | Scene is sleeping (systems stopped, entities hidden) |
| `'unloading'` | Scene is currently unloading |
| `null` | Scene is not loaded |

## Scene Layer Ordering

When multiple scenes are loaded simultaneously, rendering and system execution follow load order. Use `bringToTop()` to move a scene to the top:

```typescript
const mgr = app.getResource(SceneManager);

await mgr.loadAdditive('hud');
await mgr.loadAdditive('dialog');

mgr.bringToTop('hud');
mgr.getLoadOrder();    // ['game', 'dialog', 'hud']
```

## Scene Data Types

| Type | Fields |
|------|--------|
| `SceneData` | `version: string, name: string, entities: SceneEntityData[], textureMetadata?: Record<string, TextureMetadata>` |
| `SceneEntityData` | `id: number, name: string, parent: number \| null, children: number[], components: SceneComponentData[], visible?: boolean` |
| `SceneComponentData` | `type: string, data: Record<string, unknown>` |
