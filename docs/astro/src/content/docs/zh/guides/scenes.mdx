---
title: 场景
description: 在 ESEngine 中创建、加载和管理场景
---

import { Aside } from '@astrojs/starlight/components';

**场景**是实体、组件和父子关系的集合。你可以在 ESEngine 编辑器中可视化地创建场景，场景以 JSON 文件保存。运行时引擎会加载场景并生成所有实体及其配置的组件。

## 场景结构

场景文件包含：

- **实体** — 每个实体都有唯一 ID 和名字
- **组件** — 附加到实体上的数据（变换、精灵、碰撞体等）
- **层级** — 实体之间的父子关系

```json
{
  "version": "1.0",
  "name": "Level1",
  "entities": [
    {
      "id": 1,
      "name": "Player",
      "parent": null,
      "children": [2],
      "components": [
        { "type": "LocalTransform", "data": { "position": { "x": 0, "y": 0, "z": 0 } } },
        { "type": "Sprite", "data": { "texture": "player.png", "size": { "x": 32, "y": 32 } } }
      ]
    }
  ]
}
```

## 加载场景

在编辑器中，场景会自动加载 — 你只需编写定义组件和系统的脚本。

构建项目后，引擎会自动加载场景、解析所有引用的资源（纹理、材质、Spine），并在没有相机时创建默认相机。你不需要手动处理场景加载。

## 查找实体

### 按名字查找

从场景加载的每个实体都会自动获得内置的 `Name` 组件，包含在编辑器中指定的名字。通过查询 `Name` 来查找实体：

```typescript
import { defineSystem, addStartupSystem, Query, Name, LocalTransform } from 'esengine';

addStartupSystem(defineSystem(
    [Query(Name, LocalTransform)],
    (query) => {
        for (const [entity, name, transform] of query) {
            if (name.value === 'Player') {
                // 找到了玩家实体
            }
        }
    }
));
```

### 按组件或标签查找

使用 `Query` 按组件查找实体：

```typescript
import { defineSystem, addSystem, defineTag, Query, Mut, LocalTransform } from 'esengine';

const Player = defineTag('Player');

addSystem(defineSystem(
    [Query(Mut(LocalTransform), Player)],
    (query) => {
        for (const [entity, transform] of query) {
            // 处理每个玩家
        }
    }
));
```

### 遍历层级

使用 `Children` 组件遍历实体树：

```typescript
import { defineSystem, addSystem, Query, Children, LocalTransform } from 'esengine';

addSystem(defineSystem(
    [Query(Children, LocalTransform)],
    (query) => {
        for (const [entity, children, transform] of query) {
            // children.entities 包含子实体 ID
        }
    }
));
```

## 实体层级

场景实体可以通过父子关系形成树状结构。在编辑器中设置父子关系 — 引擎会自动管理 `Parent` 和 `Children` 组件。

当父实体的 `LocalTransform` 变化时，引擎会通过 `WorldTransform` 组件将变换传播到所有后代。

## 动态实体

你可以在运行时使用 `Commands` 生成和销毁实体：

```typescript
import { defineSystem, addSystem, Commands, LocalTransform, Sprite } from 'esengine';

addSystem(defineSystem(
    [Commands()],
    (commands) => {
        // 生成一个带组件的新实体
        commands.spawn()
            .insert(LocalTransform, { position: { x: 100, y: 0, z: 0 }, rotation: { w: 1, x: 0, y: 0, z: 0 }, scale: { x: 1, y: 1, z: 1 } })
            .insert(Sprite, { texture: bulletTexture, color: { r: 1, g: 1, b: 1, a: 1 }, size: { x: 8, y: 8 } });

        // 销毁实体
        commands.despawn(entity);
    }
));
```

<Aside type="note">
  Commands 是缓冲的，在当前调度阶段结束时应用，不会立即生效。
</Aside>

## 实体可见性

实体拥有 `visible` 属性（默认 `true`）。在编辑器中将其设为 `false` 时，场景加载会跳过该实体的组件 — 它在层级中存在但没有运行时行为。适合用于在场景文件中保留参考实体而不在运行时生成。

## 场景管理器

SDK 提供了 `SceneManager` 资源和 `sceneManagerPlugin` 插件，用于管理多个场景的加载、切换和生命周期。使用 `createWebApp()` 时会自动包含该插件，无需手动注册。

```typescript
import { SceneManager } from 'esengine';

const mgr = app.getResource(SceneManager);
```

## 注册场景

在应用启动前，使用 `app.registerScene()` 注册所有场景。每个场景需要一个唯一名称和场景文件路径，还可以配置专属系统、setup 回调和 cleanup 回调：

```typescript
import { SceneManager, type SceneConfig, Schedule } from 'esengine';

const app = createWebApp(module);

app.registerScene({
    name: 'menu',
    path: '/scenes/menu.json',
    systems: [
        { schedule: Schedule.Update, system: menuUpdateSystem },
    ],
    setup: (ctx) => {
        ctx.registerDrawCallback('menu-particles', drawParticles);
    },
    cleanup: (ctx) => {
        // 场景卸载前调用
    },
});

app.registerScene({ name: 'game', path: '/scenes/game.json' });
app.setInitialScene('menu');
app.run();
```

<Aside type="tip">
  `systems` 中注册的系统会自动包装为场景作用域系统，仅在该场景状态为 `running` 时执行。
</Aside>

## 切换场景

通过 `SceneManager` 的 `switchTo` 方法切换场景。切换会先卸载当前主场景，再加载目标场景：

```typescript
const mgr = app.getResource(SceneManager);

// 简单切换（卸载旧场景，加载新场景）
await mgr.switchTo('game');

// 带淡入淡出过渡的切换
await mgr.switchTo('game', { transition: 'fade', duration: 0.5 });
```

## 多场景（叠加加载）

除了切换主场景，还可以使用叠加加载在当前场景之上加载额外场景。适合用于 HUD、暂停菜单等需要与主场景共存的 UI 层：

```typescript
const mgr = app.getResource(SceneManager);

// 在当前场景上叠加加载
await mgr.loadAdditive('hud');
await mgr.loadAdditive('pause-menu');

// 卸载叠加场景
await mgr.unload('pause-menu');
```

<Aside type="note">
  叠加场景与主场景独立运行，各自拥有独立的系统和生命周期。卸载叠加场景不会影响主场景。
</Aside>

## 场景生命周期

每个已加载的场景都有自己的状态。你可以暂停、恢复、休眠和唤醒场景：

```typescript
const mgr = app.getResource(SceneManager);

mgr.pause('game');    // 系统停止执行，实体保持可见
mgr.resume('game');   // 恢复系统执行

mgr.sleep('game');    // 系统停止执行，实体隐藏
mgr.wake('game');     // 恢复系统执行并显示实体
```

| 方法 | 系统执行 | 实体可见 |
|------|----------|----------|
| `resume` / `wake` | 是 | 是 |
| `pause` | 否 | 是 |
| `sleep` | 否 | 否 |

## 场景上下文

场景加载时，`setup` 回调接收一个 `SceneContext` 对象，用于执行作用域为当前场景的操作：

```typescript
app.registerScene({
    name: 'game',
    path: '/scenes/game.json',
    setup: (ctx) => {
        // 生成属于此场景的实体
        const e = ctx.spawn();

        // 注册作用域为此场景的绘制回调
        ctx.registerDrawCallback('game-debug', drawDebug);

        // 添加作用域为此场景的后处理效果
        ctx.addPostProcessPass('bloom', bloomShader);

        // 标记实体为持久（场景卸载时不销毁）
        ctx.setPersistent(e, true);
    },
});
```

通过 `ctx.spawn()` 生成的实体会自动获得 `SceneOwner` 组件，在场景卸载时会被一并销毁（除非标记为持久）。

### SceneOwner 组件

从场景文件加载的实体和通过 `ctx.spawn()` 生成的实体都会自动获得 `SceneOwner` 组件，用于标识实体所属的场景：

```typescript
import { SceneOwner } from 'esengine';

// 检查实体属于哪个场景
const owner = world.get(entity, SceneOwner);
console.log(owner.scene);       // 'game'
console.log(owner.persistent);  // false
```

### 场景作用域系统

在 `registerScene` 中通过 `systems` 注册的系统会自动包装，仅在场景状态为 `running` 时执行：

```typescript
import { defineSystem, Query, Mut, LocalTransform, Schedule } from 'esengine';

const mySystem = defineSystem(
    [Query(Mut(LocalTransform))],
    (query) => {
        for (const [entity, transform] of query) {
            // 更新变换
        }
    }
);

app.registerScene({
    name: 'game',
    path: '/scenes/game.json',
    systems: [{ schedule: Schedule.Update, system: mySystem }],
});
```

<Aside type="tip">
  当场景处于 `paused` 或 `sleeping` 状态时，其作用域系统不会执行，无需手动判断场景状态。
</Aside>

## 场景过渡动画

使用 `transitionTo` 函数实现带动画效果的场景切换：

```typescript
import { transitionTo } from 'esengine';

// 淡出到黑色，切换场景，淡入
await transitionTo(app, 'game', { type: 'fade', duration: 1.0 });

// 交叉淡入淡出
await transitionTo(app, 'game', { type: 'crossfade', duration: 0.5 });
```

`transitionTo` 会处理旧场景的淡出、场景切换以及新场景的淡入，整个过程是异步的。

## 查询场景状态

`SceneManager` 提供了一组方法用于查询当前场景的状态：

```typescript
const mgr = app.getResource(SceneManager);

mgr.getActive();            // 当前主场景名，无主场景时返回 null
mgr.getActiveScenes();      // 所有状态为 'running' 的场景名数组
mgr.getLoaded();            // 所有已加载的场景名数组
mgr.isLoaded('game');       // 场景是否已加载
mgr.isPaused('game');       // 场景是否处于暂停状态
mgr.isSleeping('game');     // 场景是否处于休眠状态
mgr.getSceneStatus('game'); // 返回场景详细状态
```

`getSceneStatus` 的返回值类型为：

| 状态 | 说明 |
|------|------|
| `'loading'` | 场景正在加载中 |
| `'running'` | 场景正在运行 |
| `'paused'` | 场景已暂停（系统停止，实体可见） |
| `'sleeping'` | 场景已休眠（系统停止，实体隐藏） |
| `'unloading'` | 场景正在卸载中 |
| `null` | 场景未加载 |

## 场景数据类型

| 类型 | 字段 |
|------|------|
| `SceneData` | `version: string, name: string, entities: SceneEntityData[], textureMetadata?: Record<string, TextureMetadata>` |
| `SceneEntityData` | `id: number, name: string, parent: number \| null, children: number[], components: SceneComponentData[], visible?: boolean` |
| `SceneComponentData` | `type: string, data: Record<string, unknown>` |
