function e(e,s){return{_id:Symbol(`Builtin_${e}`),_name:e,_cppName:e,_builtin:!0,_default:s}}const s=e("RigidBody",{bodyType:2,gravityScale:1,linearDamping:0,angularDamping:0,fixedRotation:!1,bullet:!1,enabled:!0}),t=e("BoxCollider",{halfExtents:{x:.5,y:.5},offset:{x:0,y:0},density:1,friction:.3,restitution:0,isSensor:!1}),n=e("CircleCollider",{radius:.5,offset:{x:0,y:0},density:1,friction:.3,restitution:0,isSensor:!1}),i=e("CapsuleCollider",{radius:.25,halfHeight:.5,offset:{x:0,y:0},density:1,friction:.3,restitution:0,isSensor:!1}),o={Static:0,Kinematic:1,Dynamic:2};const r=(c="LocalTransform",u={position:{x:0,y:0,z:0},rotation:{w:1,x:0,y:0,z:0},scale:{x:1,y:1,z:1}},{_id:Symbol(`Builtin_${c}`),_name:c,_cppName:c,_builtin:!0,_default:u});var c,u;let y=0;function l(e,s){const t=++y;return{_id:Symbol(`Resource_${t}_${s??""}`),_name:s??`Resource_${t}`,_default:e}}const a=l({delta:0,elapsed:0,frameCount:0},"Time");var _;!function(e){e[e.Startup=0]="Startup",e[e.First=1]="First",e[e.PreUpdate=2]="PreUpdate",e[e.Update=3]="Update",e[e.PostUpdate=4]="PostUpdate",e[e.Last=5]="Last",e[e.FixedPreUpdate=10]="FixedPreUpdate",e[e.FixedUpdate=11]="FixedUpdate",e[e.FixedPostUpdate=12]="FixedPostUpdate"}(_||(_={}));let p=0;async function m(e,s){if(s)return s();return(0,(await import(e)).default)()}async function h(e,s){await s.loadDynamicLibrary(new Uint8Array(e),{loadAsync:!0,allowUndefined:!0});const t=s.cwrap.bind(s);return{_physics_init:t("physics_init",null,["number","number","number","number"]),_physics_shutdown:t("physics_shutdown",null,[]),_physics_createBody:t("physics_createBody",null,["number","number","number","number","number","number","number","number","number","number"]),_physics_destroyBody:t("physics_destroyBody",null,["number"]),_physics_hasBody:t("physics_hasBody","number",["number"]),_physics_addBoxShape:t("physics_addBoxShape",null,["number","number","number","number","number","number","number","number","number"]),_physics_addCircleShape:t("physics_addCircleShape",null,["number","number","number","number","number","number","number","number"]),_physics_addCapsuleShape:t("physics_addCapsuleShape",null,["number","number","number","number","number","number","number","number","number"]),_physics_step:t("physics_step",null,["number"]),_physics_setBodyTransform:t("physics_setBodyTransform",null,["number","number","number","number"]),_physics_getDynamicBodyCount:t("physics_getDynamicBodyCount","number",[]),_physics_getDynamicBodyTransforms:t("physics_getDynamicBodyTransforms","number",[]),_physics_collectEvents:t("physics_collectEvents",null,[]),_physics_getCollisionEnterCount:t("physics_getCollisionEnterCount","number",[]),_physics_getCollisionEnterBuffer:t("physics_getCollisionEnterBuffer","number",[]),_physics_getCollisionExitCount:t("physics_getCollisionExitCount","number",[]),_physics_getCollisionExitBuffer:t("physics_getCollisionExitBuffer","number",[]),_physics_getSensorEnterCount:t("physics_getSensorEnterCount","number",[]),_physics_getSensorEnterBuffer:t("physics_getSensorEnterBuffer","number",[]),_physics_getSensorExitCount:t("physics_getSensorExitCount","number",[]),_physics_getSensorExitBuffer:t("physics_getSensorExitBuffer","number",[]),_physics_applyForce:t("physics_applyForce",null,["number","number","number"]),_physics_applyImpulse:t("physics_applyImpulse",null,["number","number","number"]),_physics_setLinearVelocity:t("physics_setLinearVelocity",null,["number","number","number"]),_physics_getLinearVelocity:t("physics_getLinearVelocity","number",["number"]),get HEAPF32(){return s.HEAPF32},get HEAPU8(){return s.HEAPU8},get HEAPU32(){return s.HEAPU32},_malloc:s._malloc.bind(s),_free:s._free.bind(s)}}const d=l({collisionEnters:[],collisionExits:[],sensorEnters:[],sensorExits:[]},"PhysicsEvents");function f(e){return Math.atan2(2*(e.w*e.z+e.x*e.y),1-2*(e.y*e.y+e.z*e.z))}function b(e){const s=.5*e;return{w:Math.cos(s),x:0,y:0,z:Math.sin(s)}}class E{constructor(e,s={},t){this.wasmUrl_=e,this.factory_=t,this.config_={gravity:s.gravity??{x:0,y:-9.81},fixedTimestep:s.fixedTimestep??1/60,subStepCount:s.subStepCount??4}}build(e){e.insertResource(d,{collisionEnters:[],collisionExits:[],sensorEnters:[],sensorExits:[]});const t=new Set,n=m(this.wasmUrl_,this.factory_).then(n=>{n._physics_init(this.config_.gravity.x,this.config_.gravity.y,this.config_.fixedTimestep,this.config_.subStepCount);const i=e.world;var c;e.addSystemToSchedule(_.PostUpdate,function(e,s,t){const n=++p;return{_id:Symbol(`System_${n}_${t?.name}`),_params:e,_fn:s,_name:t?.name??`System_${n}`}}([(c=a,{_type:"res",_resource:c})],c=>{const u=i.getEntitiesWithComponents([s,r]),y=new Set;for(const c of u){y.add(c);const u=i.get(c,s),l=i.get(c,r);if(!t.has(c)){if(!u.enabled)continue;const s=f(l.rotation);n._physics_createBody(c,u.bodyType,l.position.x,l.position.y,s,u.gravityScale,u.linearDamping,u.angularDamping,u.fixedRotation?1:0,u.bullet?1:0),g(e,n,c),t.add(c)}if(u.bodyType===o.Kinematic){const e=f(l.rotation);n._physics_setBodyTransform(c,l.position.x,l.position.y,e)}}for(const e of t)y.has(e)||(n._physics_destroyBody(e),t.delete(e));n._physics_step(c.delta),function(e,s){const t=s._physics_getDynamicBodyCount();if(0===t)return;const n=s._physics_getDynamicBodyTransforms(),i=n>>2;for(let n=0;n<t;n++){const t=i+4*n,o=s.HEAPU32[t],c=s.HEAPF32[t+1],u=s.HEAPF32[t+2],y=s.HEAPF32[t+3];if(!e.world.valid(o))continue;const l=e.world.get(o,r);if(!l)continue;l.position.x=c,l.position.y=u;const a=b(y);l.rotation.w=a.w,l.rotation.x=a.x,l.rotation.y=a.y,l.rotation.z=a.z,e.world.insert(o,r,l)}}(e,n),function(e,s){s._physics_collectEvents();const t=[],n=s._physics_getCollisionEnterCount();if(n>0){const e=s._physics_getCollisionEnterBuffer()>>2;for(let i=0;i<n;i++){const n=e+6*i;t.push({entityA:s.HEAPU32[n],entityB:s.HEAPU32[n+1],normalX:s.HEAPF32[n+2],normalY:s.HEAPF32[n+3],contactX:s.HEAPF32[n+4],contactY:s.HEAPF32[n+5]})}}const i=[],o=s._physics_getCollisionExitCount();if(o>0){const e=s._physics_getCollisionExitBuffer()>>2;for(let t=0;t<o;t++){const n=e+2*t;i.push({entityA:s.HEAPU32[n],entityB:s.HEAPU32[n+1]})}}const r=[],c=s._physics_getSensorEnterCount();if(c>0){const e=s._physics_getSensorEnterBuffer()>>2;for(let t=0;t<c;t++){const n=e+2*t;r.push({sensorEntity:s.HEAPU32[n],visitorEntity:s.HEAPU32[n+1]})}}const u=[],y=s._physics_getSensorExitCount();if(y>0){const e=s._physics_getSensorExitBuffer()>>2;for(let t=0;t<y;t++){const n=e+2*t;u.push({sensorEntity:s.HEAPU32[n],visitorEntity:s.HEAPU32[n+1]})}}e.insertResource(d,{collisionEnters:t,collisionExits:i,sensorEnters:r,sensorExits:u})}(e,n)},{name:"PhysicsSystem"})),e.__physicsModule=n});e.__physicsInitPromise=n}}function g(e,s,o){const r=e.world;if(r.has(o,t)){const e=r.get(o,t);return void s._physics_addBoxShape(o,e.halfExtents.x,e.halfExtents.y,e.offset.x,e.offset.y,e.density,e.friction,e.restitution,e.isSensor?1:0)}if(r.has(o,n)){const e=r.get(o,n);return void s._physics_addCircleShape(o,e.radius,e.offset.x,e.offset.y,e.density,e.friction,e.restitution,e.isSensor?1:0)}if(r.has(o,i)){const e=r.get(o,i);s._physics_addCapsuleShape(o,e.radius,e.halfHeight,e.offset.x,e.offset.y,e.density,e.friction,e.restitution,e.isSensor?1:0)}}class x{constructor(e){if(this.module_=e.__physicsModule,!this.module_)throw new Error("Physics module not loaded. Ensure PhysicsPlugin init is complete.")}applyForce(e,s){this.module_._physics_applyForce(e,s.x,s.y)}applyImpulse(e,s){this.module_._physics_applyImpulse(e,s.x,s.y)}setLinearVelocity(e,s){this.module_._physics_setLinearVelocity(e,s.x,s.y)}getLinearVelocity(e){const s=this.module_._physics_getLinearVelocity(e)>>2;return{x:this.module_.HEAPF32[s],y:this.module_.HEAPF32[s+1]}}}export{o as BodyType,t as BoxCollider,i as CapsuleCollider,n as CircleCollider,x as Physics,d as PhysicsEvents,E as PhysicsPlugin,s as RigidBody,m as loadPhysicsModule,h as loadPhysicsSideModule};
//# sourceMappingURL=index.js.map
