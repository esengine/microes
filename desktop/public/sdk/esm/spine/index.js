let e=0;function t(t,n){const r=++e;return{_id:Symbol(`Resource_${r}_${n??""}`),_name:n??`Resource_${r}`,_default:t}}function n(e){const t=e.cwrap.bind(e);return{loadSkeleton:t("spine_loadSkeleton","number",["number","number","string","number","number"]),getLastError:t("spine_getLastError","string",[]),unloadSkeleton:t("spine_unloadSkeleton",null,["number"]),getAtlasPageCount:t("spine_getAtlasPageCount","number",["number"]),getAtlasPageTextureName:t("spine_getAtlasPageTextureName","string",["number","number"]),setAtlasPageTexture:t("spine_setAtlasPageTexture",null,["number","number","number","number","number"]),createInstance:t("spine_createInstance","number",["number"]),destroyInstance:t("spine_destroyInstance",null,["number"]),playAnimation:t("spine_playAnimation","number",["number","string","number","number"]),addAnimation:t("spine_addAnimation","number",["number","string","number","number","number"]),setSkin:t("spine_setSkin",null,["number","string"]),update:t("spine_update",null,["number","number"]),getAnimations:t("spine_getAnimations","string",["number"]),getSkins:t("spine_getSkins","string",["number"]),getBonePosition:t("spine_getBonePosition","number",["number","string","number","number"]),getBoneRotation:t("spine_getBoneRotation","number",["number","string"]),getBounds:t("spine_getBounds",null,["number","number","number","number","number"]),getMeshBatchCount:t("spine_getMeshBatchCount","number",["number"]),getMeshBatchVertexCount:t("spine_getMeshBatchVertexCount","number",["number","number"]),getMeshBatchIndexCount:t("spine_getMeshBatchIndexCount","number",["number","number"]),getMeshBatchData:t("spine_getMeshBatchData",null,["number","number","number","number","number","number"])}}async function r(e,t){let r;if(t)r=await t();else{const t=(await import(e)).default;r=await t()}return{raw:r,api:n(r)}}t({delta:0,elapsed:0,frameCount:0},"Time");class s{constructor(e,t){this.raw_=e,this.api_=t,this.listeners_=new Map}get raw(){return this.raw_}loadSkeleton(e,t,n){let r,s;if("string"==typeof e){const t=(new TextEncoder).encode(e);s=t.length,r=this.raw_._malloc(s+1),this.raw_.HEAPU8.set(t,r),this.raw_.HEAPU8[r+s]=0}else s=e.length,r=this.raw_._malloc(s),this.raw_.HEAPU8.set(e,r);const i=this.api_.loadSkeleton(r,s,t,t.length,n);return this.raw_._free(r),i}getLastError(){return this.api_.getLastError()}unloadSkeleton(e){this.api_.unloadSkeleton(e)}getAtlasPageCount(e){return this.api_.getAtlasPageCount(e)}getAtlasPageTextureName(e,t){return this.api_.getAtlasPageTextureName(e,t)}setAtlasPageTexture(e,t,n,r,s){this.api_.setAtlasPageTexture(e,t,n,r,s)}createInstance(e){return this.api_.createInstance(e)}destroyInstance(e){this.api_.destroyInstance(e),this.listeners_.delete(e)}play(e,t,n=!0,r=0){return!!this.api_.playAnimation(e,t,n,r)}addAnimation(e,t,n=!0,r=0,s=0){return!!this.api_.addAnimation(e,t,n,r,s)}setSkin(e,t){this.api_.setSkin(e,t)}update(e,t){this.api_.update(e,t)}getAnimations(e){const t=this.api_.getAnimations(e);try{return JSON.parse(t)}catch{return[]}}getSkins(e){const t=this.api_.getSkins(e);try{return JSON.parse(t)}catch{return[]}}getBonePosition(e,t){const n=this.raw_._malloc(4),r=this.raw_._malloc(4);if(!this.api_.getBonePosition(e,t,n,r))return this.raw_._free(n),this.raw_._free(r),null;const s=this.raw_.HEAPF32[n>>2],i=this.raw_.HEAPF32[r>>2];return this.raw_._free(n),this.raw_._free(r),{x:s,y:i}}getBoneRotation(e,t){return this.api_.getBoneRotation(e,t)}getBounds(e){const t=this.raw_._malloc(16);this.api_.getBounds(e,t,t+4,t+8,t+12);const n=this.raw_.HEAPF32,r=t>>2,s={x:n[r],y:n[r+1],width:n[r+2],height:n[r+3]};return this.raw_._free(t),s}extractMeshBatches(e){const t=this.api_.getMeshBatchCount(e),n=[],r=this.raw_._malloc(8),s=r,i=r+4;for(let r=0;r<t;r++){const t=this.api_.getMeshBatchVertexCount(e,r),a=this.api_.getMeshBatchIndexCount(e,r);if(t<=0||a<=0)continue;const o=8*t*4,u=2*a,l=this.raw_._malloc(o),_=this.raw_._malloc(u);this.api_.getMeshBatchData(e,r,l,_,s,i);const h=new Float32Array(this.raw_.HEAPF32.buffer,l,8*t),c=new Uint16Array(this.raw_.HEAPU8.buffer,_,a);n.push({vertices:new Float32Array(h),indices:new Uint16Array(c),textureId:this.raw_.HEAPU32[s>>2],blendMode:this.raw_.HEAPU32[i>>2]}),this.raw_._free(l),this.raw_._free(_)}return this.raw_._free(r),n}on(e,t,n){this.listeners_.has(e)||this.listeners_.set(e,new Map);const r=this.listeners_.get(e);r.has(t)||r.set(t,new Set),r.get(t).add(n)}off(e,t,n){const r=this.listeners_.get(e);if(!r)return;const s=r.get(t);s&&s.delete(n)}removeAllListeners(e){this.listeners_.delete(e)}}const i=t(null,"SpineController");class a{constructor(e,t){this.wasmUrl_=e,this.factory_=t}build(e){const t=e.wasmModule,n=r(this.wasmUrl_,this.factory_).then(({raw:n,api:r})=>{const a=new s(n,r);return e.insertResource(i,a),{controller:a,coreModule:t}});e.insertResource(i,null),e.__spineInitPromise=n}}let o=0,u=0,l=0,_=0,h=0,c=null;function m(e,t,n,r){if(t&&n>=r)return[t,n];t&&e._free(t);const s=2*r;return[e._malloc(s),s]}function g(e,t,n,r,s){c&&c!==e&&c&&(o&&(c._free(o),o=0,u=0),l&&(c._free(l),l=0,_=0),h&&(c._free(h),h=0),c=null),c=e;const i=t.extractMeshBatches(n);r&&(h||(h=e._malloc(64)),e.HEAPF32.set(r,h>>2));const a=s&&(1!==s.r||1!==s.g||1!==s.b||1!==s.a);for(const t of i){let n=t.vertices;if(a){const e=t.blendMode>=4;n=new Float32Array(n);for(let t=0;t<n.length;t+=8)e?(n[t+4]*=s.r*s.a,n[t+5]*=s.g*s.a,n[t+6]*=s.b*s.a):(n[t+4]*=s.r,n[t+5]*=s.g,n[t+6]*=s.b),n[t+7]*=s.a}const i=n.byteLength,c=t.indices.byteLength;[o,u]=m(e,o,u,i),[l,_]=m(e,l,_,c),e.HEAPF32.set(n,o>>2),new Uint16Array(e.HEAPU8.buffer,l,t.indices.length).set(t.indices),e.renderer_submitTriangles(o,n.length/8,l,t.indices.length,t.textureId,t.blendMode,r?h:0)}}export{s as SpineModuleController,a as SpinePlugin,i as SpineResource,r as loadSpineModule,g as submitSpineMeshesToCore,n as wrapSpineModule};
//# sourceMappingURL=index.js.map
