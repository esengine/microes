let e=0;function t(t,n){const s=++e;return{_id:Symbol(`Resource_${s}_${n??""}`),_name:n??`Resource_${s}`,_default:t}}function n(e){const t=e.cwrap.bind(e);return{loadSkeleton:t("spine_loadSkeleton","number",["number","number","string","number","number"]),unloadSkeleton:t("spine_unloadSkeleton",null,["number"]),getAtlasPageCount:t("spine_getAtlasPageCount","number",["number"]),getAtlasPageTextureName:t("spine_getAtlasPageTextureName","string",["number","number"]),setAtlasPageTexture:t("spine_setAtlasPageTexture",null,["number","number","number","number","number"]),createInstance:t("spine_createInstance","number",["number"]),destroyInstance:t("spine_destroyInstance",null,["number"]),playAnimation:t("spine_playAnimation","number",["number","string","number","number"]),addAnimation:t("spine_addAnimation","number",["number","string","number","number","number"]),setSkin:t("spine_setSkin",null,["number","string"]),update:t("spine_update",null,["number","number"]),getAnimations:t("spine_getAnimations","string",["number"]),getSkins:t("spine_getSkins","string",["number"]),getBonePosition:t("spine_getBonePosition","number",["number","string","number","number"]),getBoneRotation:t("spine_getBoneRotation","number",["number","string"]),getBounds:t("spine_getBounds",null,["number","number","number","number","number"]),getMeshBatchCount:t("spine_getMeshBatchCount","number",["number"]),getMeshBatchVertexCount:t("spine_getMeshBatchVertexCount","number",["number","number"]),getMeshBatchIndexCount:t("spine_getMeshBatchIndexCount","number",["number","number"]),getMeshBatchData:t("spine_getMeshBatchData",null,["number","number","number","number","number","number"])}}async function s(e,t){let s;if(t)s=await t();else{const t=(await import(e)).default;s=await t()}return{raw:s,api:n(s)}}t({delta:0,elapsed:0,frameCount:0},"Time");class r{constructor(e,t){this.raw_=e,this.api_=t,this.listeners_=new Map}get raw(){return this.raw_}loadSkeleton(e,t,n){let s,r;if("string"==typeof e){const t=(new TextEncoder).encode(e);r=t.length,s=this.raw_._malloc(r+1),this.raw_.HEAPU8.set(t,s),this.raw_.HEAPU8[s+r]=0}else r=e.length,s=this.raw_._malloc(r),this.raw_.HEAPU8.set(e,s);const i=this.api_.loadSkeleton(s,r,t,t.length,n);return this.raw_._free(s),i}unloadSkeleton(e){this.api_.unloadSkeleton(e)}getAtlasPageCount(e){return this.api_.getAtlasPageCount(e)}getAtlasPageTextureName(e,t){return this.api_.getAtlasPageTextureName(e,t)}setAtlasPageTexture(e,t,n,s,r){this.api_.setAtlasPageTexture(e,t,n,s,r)}createInstance(e){return this.api_.createInstance(e)}destroyInstance(e){this.api_.destroyInstance(e),this.listeners_.delete(e)}play(e,t,n=!0,s=0){return!!this.api_.playAnimation(e,t,n,s)}addAnimation(e,t,n=!0,s=0,r=0){return!!this.api_.addAnimation(e,t,n,s,r)}setSkin(e,t){this.api_.setSkin(e,t)}update(e,t){this.api_.update(e,t)}getAnimations(e){const t=this.api_.getAnimations(e);try{return JSON.parse(t)}catch{return[]}}getSkins(e){const t=this.api_.getSkins(e);try{return JSON.parse(t)}catch{return[]}}getBonePosition(e,t){const n=this.raw_._malloc(4),s=this.raw_._malloc(4);if(!this.api_.getBonePosition(e,t,n,s))return this.raw_._free(n),this.raw_._free(s),null;const r=this.raw_.HEAPF32[n>>2],i=this.raw_.HEAPF32[s>>2];return this.raw_._free(n),this.raw_._free(s),{x:r,y:i}}getBoneRotation(e,t){return this.api_.getBoneRotation(e,t)}getBounds(e){const t=this.raw_._malloc(16);this.api_.getBounds(e,t,t+4,t+8,t+12);const n=this.raw_.HEAPF32,s=t>>2,r={x:n[s],y:n[s+1],width:n[s+2],height:n[s+3]};return this.raw_._free(t),r}extractMeshBatches(e){const t=this.api_.getMeshBatchCount(e),n=[],s=this.raw_._malloc(8),r=s,i=s+4;for(let s=0;s<t;s++){const t=this.api_.getMeshBatchVertexCount(e,s),a=this.api_.getMeshBatchIndexCount(e,s);if(t<=0||a<=0)continue;const o=8*t*4,u=2*a,l=this.raw_._malloc(o),_=this.raw_._malloc(u);this.api_.getMeshBatchData(e,s,l,_,r,i);const h=new Float32Array(this.raw_.HEAPF32.buffer,l,8*t),c=new Uint16Array(this.raw_.HEAPU8.buffer,_,a);n.push({vertices:new Float32Array(h),indices:new Uint16Array(c),textureId:this.raw_.HEAPU32[r>>2],blendMode:this.raw_.HEAPU32[i>>2]}),this.raw_._free(l),this.raw_._free(_)}return this.raw_._free(s),n}on(e,t,n){this.listeners_.has(e)||this.listeners_.set(e,new Map);const s=this.listeners_.get(e);s.has(t)||s.set(t,new Set),s.get(t).add(n)}off(e,t,n){const s=this.listeners_.get(e);if(!s)return;const r=s.get(t);r&&r.delete(n)}removeAllListeners(e){this.listeners_.delete(e)}}const i=t(null,"SpineController");class a{constructor(e,t){this.wasmUrl_=e,this.factory_=t}build(e){const t=e.wasmModule,n=s(this.wasmUrl_,this.factory_).then(({raw:n,api:s})=>{const a=new r(n,s);return e.insertResource(i,a),{controller:a,coreModule:t}});e.insertResource(i,null),e.__spineInitPromise=n}}function o(e,t,n,s){const r=t.extractMeshBatches(n);let i=0;s&&(i=e._malloc(64),e.HEAPF32.set(s,i>>2));for(const t of r){const n=t.vertices.byteLength,s=t.indices.byteLength,r=e._malloc(n),a=e._malloc(s);e.HEAPF32.set(t.vertices,r>>2),new Uint16Array(e.HEAPU8.buffer,a,t.indices.length).set(t.indices),e.renderer_submitTriangles(r,t.vertices.length/8,a,t.indices.length,t.textureId,t.blendMode,i),e._free(r),e._free(a)}i&&e._free(i)}export{r as SpineModuleController,a as SpinePlugin,i as SpineResource,s as loadSpineModule,o as submitSpineMeshesToCore,n as wrapSpineModule};
//# sourceMappingURL=index.js.map
