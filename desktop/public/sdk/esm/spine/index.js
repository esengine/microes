let e=0;function t(t,n){const r=++e;return{_id:Symbol(`Resource_${r}_${n??""}`),_name:n??`Resource_${r}`,_default:t}}function n(e){const t=e.cwrap.bind(e);return{loadSkeleton:t("spine_loadSkeleton","number",["number","number","string","number","number"]),getLastError:t("spine_getLastError","string",[]),unloadSkeleton:t("spine_unloadSkeleton",null,["number"]),getAtlasPageCount:t("spine_getAtlasPageCount","number",["number"]),getAtlasPageTextureName:t("spine_getAtlasPageTextureName","string",["number","number"]),setAtlasPageTexture:t("spine_setAtlasPageTexture",null,["number","number","number","number","number"]),createInstance:t("spine_createInstance","number",["number"]),destroyInstance:t("spine_destroyInstance",null,["number"]),playAnimation:t("spine_playAnimation","number",["number","string","number","number"]),addAnimation:t("spine_addAnimation","number",["number","string","number","number","number"]),setSkin:t("spine_setSkin",null,["number","string"]),update:t("spine_update",null,["number","number"]),getAnimations:t("spine_getAnimations","string",["number"]),getSkins:t("spine_getSkins","string",["number"]),getBonePosition:t("spine_getBonePosition","number",["number","string","number","number"]),getBoneRotation:t("spine_getBoneRotation","number",["number","string"]),getBounds:t("spine_getBounds",null,["number","number","number","number","number"]),getMeshBatchCount:t("spine_getMeshBatchCount","number",["number"]),getMeshBatchVertexCount:t("spine_getMeshBatchVertexCount","number",["number","number"]),getMeshBatchIndexCount:t("spine_getMeshBatchIndexCount","number",["number","number"]),getMeshBatchData:t("spine_getMeshBatchData",null,["number","number","number","number","number","number"])}}async function r(e,t){let r;if(t)r=await t();else{const t=(await import(e)).default;r=await t()}return{raw:r,api:n(r)}}t({delta:0,elapsed:0,frameCount:0},"Time");class s{constructor(e,t){this.raw_=e,this.api_=t,this.listeners_=new Map}get raw(){return this.raw_}loadSkeleton(e,t,n){let r,s;if("string"==typeof e){const t=(new TextEncoder).encode(e);s=t.length,r=this.raw_._malloc(s+1),this.raw_.HEAPU8.set(t,r),this.raw_.HEAPU8[r+s]=0}else s=e.length,r=this.raw_._malloc(s),this.raw_.HEAPU8.set(e,r);const i=this.api_.loadSkeleton(r,s,t,t.length,n);return this.raw_._free(r),i}getLastError(){return this.api_.getLastError()}unloadSkeleton(e){this.api_.unloadSkeleton(e)}getAtlasPageCount(e){return this.api_.getAtlasPageCount(e)}getAtlasPageTextureName(e,t){return this.api_.getAtlasPageTextureName(e,t)}setAtlasPageTexture(e,t,n,r,s){this.api_.setAtlasPageTexture(e,t,n,r,s)}createInstance(e){return this.api_.createInstance(e)}destroyInstance(e){this.api_.destroyInstance(e),this.listeners_.delete(e)}play(e,t,n=!0,r=0){return!!this.api_.playAnimation(e,t,n,r)}addAnimation(e,t,n=!0,r=0,s=0){return!!this.api_.addAnimation(e,t,n,r,s)}setSkin(e,t){this.api_.setSkin(e,t)}update(e,t){this.api_.update(e,t)}getAnimations(e){const t=this.api_.getAnimations(e);try{return JSON.parse(t)}catch{return[]}}getSkins(e){const t=this.api_.getSkins(e);try{return JSON.parse(t)}catch{return[]}}getBonePosition(e,t){const n=this.raw_._malloc(4),r=this.raw_._malloc(4);if(!this.api_.getBonePosition(e,t,n,r))return this.raw_._free(n),this.raw_._free(r),null;const s=this.raw_.HEAPF32[n>>2],i=this.raw_.HEAPF32[r>>2];return this.raw_._free(n),this.raw_._free(r),{x:s,y:i}}getBoneRotation(e,t){return this.api_.getBoneRotation(e,t)}getBounds(e){const t=this.raw_._malloc(16);this.api_.getBounds(e,t,t+4,t+8,t+12);const n=this.raw_.HEAPF32,r=t>>2,s={x:n[r],y:n[r+1],width:n[r+2],height:n[r+3]};return this.raw_._free(t),s}extractMeshBatches(e){const t=this.api_.getMeshBatchCount(e),n=[],r=this.raw_._malloc(8),s=r,i=r+4;for(let r=0;r<t;r++){const t=this.api_.getMeshBatchVertexCount(e,r),a=this.api_.getMeshBatchIndexCount(e,r);if(t<=0||a<=0)continue;const o=8*t*4,u=2*a,l=this.raw_._malloc(o),_=this.raw_._malloc(u);this.api_.getMeshBatchData(e,r,l,_,s,i);const h=new Float32Array(this.raw_.HEAPF32.buffer,l,8*t),c=new Uint16Array(this.raw_.HEAPU8.buffer,_,a);n.push({vertices:new Float32Array(h),indices:new Uint16Array(c),textureId:this.raw_.HEAPU32[s>>2],blendMode:this.raw_.HEAPU32[i>>2]}),this.raw_._free(l),this.raw_._free(_)}return this.raw_._free(r),n}on(e,t,n){this.listeners_.has(e)||this.listeners_.set(e,new Map);const r=this.listeners_.get(e);r.has(t)||r.set(t,new Set),r.get(t).add(n)}off(e,t,n){const r=this.listeners_.get(e);if(!r)return;const s=r.get(t);s&&s.delete(n)}removeAllListeners(e){this.listeners_.delete(e)}}const i=t(null,"SpineController");class a{constructor(e,t){this.wasmUrl_=e,this.factory_=t}build(e){const t=e.wasmModule,n=r(this.wasmUrl_,this.factory_).then(({raw:n,api:r})=>{const a=new s(n,r);return e.insertResource(i,a),{controller:a,coreModule:t}});e.insertResource(i,null),e.__spineInitPromise=n}}function o(e,t,n,r,s){const i=t.extractMeshBatches(n);let a=0;r&&(a=e._malloc(64),e.HEAPF32.set(r,a>>2));const o=s&&(1!==s.x||1!==s.y||1!==s.z||1!==s.w);for(const t of i){let n=t.vertices;if(o){n=new Float32Array(n);for(let e=0;e<n.length;e+=8)n[e+4]*=s.x,n[e+5]*=s.y,n[e+6]*=s.z,n[e+7]*=s.w}const r=n.byteLength,i=t.indices.byteLength,u=e._malloc(r),l=e._malloc(i);e.HEAPF32.set(n,u>>2),new Uint16Array(e.HEAPU8.buffer,l,t.indices.length).set(t.indices),e.renderer_submitTriangles(u,n.length/8,l,t.indices.length,t.textureId,t.blendMode,a),e._free(u),e._free(l)}a&&e._free(a)}export{s as SpineModuleController,a as SpinePlugin,i as SpineResource,r as loadSpineModule,o as submitSpineMeshesToCore,n as wrapSpineModule};
//# sourceMappingURL=index.js.map
