let e=0;function t(t,s){const n=++e;return{_id:Symbol(`Resource_${n}_${s??""}`),_name:s??`Resource_${n}`,_default:t}}async function s(e,t){if(t)return t();return(0,(await import(e)).default)()}t({delta:0,elapsed:0,frameCount:0},"Time");class n{constructor(e){this.module_=e,this.listeners_=new Map}get module(){return this.module_}loadSkeleton(e,t,s){return this.module_.spine_loadSkeleton(e,t,t.length,s)}unloadSkeleton(e){this.module_.spine_unloadSkeleton(e)}getAtlasPageCount(e){return this.module_.spine_getAtlasPageCount(e)}getAtlasPageTextureName(e,t){return this.module_.spine_getAtlasPageTextureName(e,t)}setAtlasPageTexture(e,t,s,n,o){this.module_.spine_setAtlasPageTexture(e,t,s,n,o)}createInstance(e){return this.module_.spine_createInstance(e)}destroyInstance(e){this.module_.spine_destroyInstance(e),this.listeners_.delete(e)}play(e,t,s=!0,n=0){return this.module_.spine_playAnimation(e,t,s,n)}addAnimation(e,t,s=!0,n=0,o=0){return this.module_.spine_addAnimation(e,t,s,n,o)}setSkin(e,t){this.module_.spine_setSkin(e,t)}update(e,t){this.module_.spine_update(e,t)}getAnimations(e){const t=this.module_.spine_getAnimations(e);try{return JSON.parse(t)}catch{return[]}}getSkins(e){const t=this.module_.spine_getSkins(e);try{return JSON.parse(t)}catch{return[]}}getBonePosition(e,t){const s=this.module_._malloc(4),n=this.module_._malloc(4);if(!this.module_.spine_getBonePosition(e,t,s,n))return this.module_._free(s),this.module_._free(n),null;const o=this.module_.HEAPF32[s>>2],i=this.module_.HEAPF32[n>>2];return this.module_._free(s),this.module_._free(n),{x:o,y:i}}getBoneRotation(e,t){return this.module_.spine_getBoneRotation(e,t)}getBounds(e){const t=this.module_._malloc(16);this.module_.spine_getBounds(e,t,t+4,t+8,t+12);const s=this.module_.HEAPF32,n=t>>2,o={x:s[n],y:s[n+1],width:s[n+2],height:s[n+3]};return this.module_._free(t),o}extractMeshBatches(e){const t=this.module_.spine_getMeshBatchCount(e),s=[],n=this.module_._malloc(8),o=n,i=n+4;for(let n=0;n<t;n++){const t=this.module_.spine_getMeshBatchVertexCount(e,n),r=this.module_.spine_getMeshBatchIndexCount(e,n);if(t<=0||r<=0)continue;const l=8*t*4,u=2*r,_=this.module_._malloc(l),a=this.module_._malloc(u);this.module_.spine_getMeshBatchData(e,n,_,a,o,i);const d=new Float32Array(this.module_.HEAPF32.buffer,_,8*t),h=new Uint16Array(this.module_.HEAPU8.buffer,a,r);s.push({vertices:new Float32Array(d),indices:new Uint16Array(h),textureId:this.module_.HEAPU32[o>>2],blendMode:this.module_.HEAPU32[i>>2]}),this.module_._free(_),this.module_._free(a)}return this.module_._free(n),s}on(e,t,s){this.listeners_.has(e)||this.listeners_.set(e,new Map);const n=this.listeners_.get(e);n.has(t)||n.set(t,new Set),n.get(t).add(s)}off(e,t,s){const n=this.listeners_.get(e);if(!n)return;const o=n.get(t);o&&o.delete(s)}removeAllListeners(e){this.listeners_.delete(e)}}const o=t(null,"SpineController");class i{constructor(e,t){this.wasmUrl_=e,this.factory_=t}build(e){const t=e.wasmModule,i=s(this.wasmUrl_,this.factory_).then(s=>{const i=new n(s);return e.insertResource(o,i),{controller:i,coreModule:t}});e.insertResource(o,null),e.__spineInitPromise=i}}function r(e,t,s,n){const o=t.extractMeshBatches(s);let i=0;n&&(i=e._malloc(64),e.HEAPF32.set(n,i>>2));for(const t of o){const s=t.vertices.byteLength,n=t.indices.byteLength,o=e._malloc(s),r=e._malloc(n);e.HEAPF32.set(t.vertices,o>>2),new Uint16Array(e.HEAPU8.buffer,r,t.indices.length).set(t.indices),e.renderer_submitTriangles(o,t.vertices.length/8,r,t.indices.length,t.textureId,t.blendMode,i),e._free(o),e._free(r)}i&&e._free(i)}export{n as SpineModuleController,i as SpinePlugin,o as SpineResource,s as loadSpineModule,r as submitSpineMeshesToCore};
//# sourceMappingURL=index.js.map
