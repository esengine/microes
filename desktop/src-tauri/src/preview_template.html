<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESEngine Preview</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #1a1a2e; }
        #canvas { width: 100%; height: 100%; display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e0e0e0;
            font-family: system-ui, sans-serif;
            font-size: 14px;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-family: monospace;
            font-size: 13px;
            max-width: 80%;
            white-space: pre-wrap;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">Loading...</div>
    <div id="error"></div>

    <script type="module">
        const loading = document.getElementById('loading');
        const errorDiv = document.getElementById('error');

        function showError(msg) {
            loading.style.display = 'none';
            errorDiv.style.display = 'block';
            errorDiv.textContent = msg;
            console.error('Preview Error:', msg);
        }

        // TextureManager - loads images and creates GPU textures
        class TextureManager {
            constructor(module) {
                this.module_ = module;
                this.cache_ = new Map();
            }

            async loadTexture(path) {
                if (!path || typeof path !== 'string') return 0;
                if (this.cache_.has(path)) return this.cache_.get(path);

                try {
                    const response = await fetch(`/${path}`);
                    if (!response.ok) {
                        console.warn(`Failed to load texture: ${path}`);
                        return 0;
                    }

                    const blob = await response.blob();
                    const img = await createImageBitmap(blob);

                    const canvas = new OffscreenCanvas(img.width, img.height);
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);

                    const rm = this.module_.getResourceManager();
                    const handle = rm.createTexture(
                        img.width, img.height,
                        imageData.data.buffer, imageData.data.length,
                        1  // RGBA format
                    );

                    this.cache_.set(path, handle);
                    console.log(`Loaded texture: ${path} -> handle ${handle}`);
                    return handle;
                } catch (err) {
                    console.warn(`Error loading texture ${path}:`, err);
                    return 0;
                }
            }
        }

        async function loadSceneData(module, registry, sceneData, textureManager) {
            console.log('Loading scene:', sceneData.name);

            for (const entityData of sceneData.entities || []) {
                const entity = registry.create();

                for (const comp of entityData.components || []) {
                    const compName = comp.type;
                    const compData = { ...comp.data };

                    // Resolve texture paths for Sprite components
                    if (compName === 'Sprite' && typeof compData.texture === 'string') {
                        compData.texture = await textureManager.loadTexture(compData.texture);
                    }

                    const addMethod = `add${compName}`;
                    if (typeof registry[addMethod] === 'function' && module[compName]) {
                        const component = new module[compName]();
                        Object.assign(component, compData);
                        registry[addMethod](entity, component);
                    }
                }
            }
        }

        async function loadPreview() {
            try {
                // Load scene data
                const sceneRes = await fetch('/.esengine/preview/scene.json');
                if (!sceneRes.ok) throw new Error('Failed to load scene.json');
                const sceneData = await sceneRes.json();

                // Load WASM module
                const Module = await import('/esengine.js');
                const module = await Module.default();

                // Create registry and initialize renderer
                const registry = new module.Registry();
                module.initRenderer();

                // Create texture manager
                const textureManager = new TextureManager(module);

                // Load scene into registry (with texture loading)
                await loadSceneData(module, registry, sceneData, textureManager);

                // Load user scripts (optional)
                try {
                    await import('/.esengine/preview/user-scripts.js');
                } catch (e) {
                    console.warn('No user scripts:', e.message);
                }

                loading.style.display = 'none';

                // Main loop
                const canvas = document.getElementById('canvas');
                function loop() {
                    module.renderFrame(registry, canvas.width, canvas.height);
                    requestAnimationFrame(loop);
                }
                requestAnimationFrame(loop);
            } catch (err) {
                showError(err.message);
            }
        }

        loadPreview();
    </script>
</body>
</html>
