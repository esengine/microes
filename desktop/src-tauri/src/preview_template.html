<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESEngine Preview</title>
    <script type="importmap">
    {
        "imports": {
            "esengine": "/sdk/index.js",
            "esengine/wasm": "/sdk/wasm.js",
            "esengine/spine": "/sdk/spine/index.js"
        }
    }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #1a1a2e; }
        #canvas { width: 100%; height: 100%; display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e0e0e0;
            font-family: system-ui, sans-serif;
            font-size: 14px;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-family: monospace;
            font-size: 13px;
            max-width: 80%;
            white-space: pre-wrap;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">Loading...</div>
    <div id="error"></div>

    <script type="module">
        const loading = document.getElementById('loading');
        const errorDiv = document.getElementById('error');

        let gameApp = null;

        function sendToEditor(type, data) {
            try {
                window.parent.postMessage({ type, data }, '*');
            } catch (e) { /* ignore */ }
        }

        const _origLog = console.log;
        const _origWarn = console.warn;
        const _origError = console.error;
        function formatArgs(args) {
            return args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
        }
        console.log = (...args) => {
            _origLog.apply(console, args);
            sendToEditor('console:log', { message: formatArgs(args) });
        };
        console.warn = (...args) => {
            _origWarn.apply(console, args);
            sendToEditor('console:warn', { message: formatArgs(args) });
        };
        console.error = (...args) => {
            _origError.apply(console, args);
            sendToEditor('console:error', { message: formatArgs(args) });
        };

        let _frameCount = 0;
        let _lastStatsTime = performance.now();
        function reportStats() {
            _frameCount++;
            const now = performance.now();
            if (now - _lastStatsTime >= 1000) {
                const fps = Math.round(_frameCount * 1000 / (now - _lastStatsTime));
                const entityCount = gameApp?.world?.getAllEntities()?.length ?? 0;
                sendToEditor('stats', { fps, entityCount });
                _frameCount = 0;
                _lastStatsTime = now;
            }
            requestAnimationFrame(reportStats);
        }

        window.addEventListener('message', (event) => {
            if (event.source !== window.parent) return;
            const msg = event.data;
            if (!msg || typeof msg !== 'object' || !msg.type) return;

            const { type, requestId } = msg;
            let response = null;

            try {
                switch (type) {
                    case 'pause':
                        gameApp?.setPaused(true);
                        response = { success: true };
                        break;
                    case 'resume':
                        gameApp?.setPaused(false);
                        response = { success: true };
                        break;
                    case 'step':
                        gameApp?.stepFrame();
                        response = { success: true };
                        break;
                    case 'set-speed':
                        gameApp?.setPlaySpeed(msg.speed ?? 1);
                        response = { success: true };
                        break;
                    case 'query-entity-list':
                        response = getEntityList();
                        break;
                    case 'query-entity':
                        response = getEntityData(msg.entityId);
                        break;
                    case 'set-entity-property':
                        setEntityProperty(msg.entityId, msg.component, msg.property, msg.value);
                        response = { success: true };
                        break;
                    case 'query-stats': {
                        const entities = gameApp?.world?.getAllEntities() ?? [];
                        response = { entityCount: entities.length, paused: gameApp?.isPaused() ?? false };
                        break;
                    }
                }
                if (requestId !== undefined) {
                    window.parent.postMessage({ type, requestId, data: response }, '*');
                }
            } catch (e) {
                if (requestId !== undefined) {
                    try {
                        window.parent.postMessage({ type, requestId, data: { error: e.message || String(e) } }, '*');
                    } catch {}
                }
            }
        });

        function getEntityList() {
            if (!gameApp) return [];
            const world = gameApp.world;
            const sdk = window.__esSdk;
            const rawEntities = world.getAllEntities();
            const entities = [];
            for (let i = 0; i < rawEntities.length; i++) entities.push(Number(rawEntities[i]));
            return entities.map(entityId => {
                const name = getEntityName(world, entityId);
                const componentTypes = getComponentTypes(world, entityId);
                const parentId = getEntityParentId(world, sdk, entityId);
                const children = getEntityChildren(world, sdk, entityId);
                return { entityId, name, parentId, children, components: componentTypes.map(t => ({ type: t, data: {} })) };
            });
        }

        function getEntityData(entityId) {
            if (!gameApp) return null;
            const world = gameApp.world;
            const sdk = window.__esSdk;
            const name = getEntityName(world, entityId);
            const componentTypes = getComponentTypes(world, entityId);
            const parentId = getEntityParentId(world, sdk, entityId);
            const children = getEntityChildren(world, sdk, entityId);
            const components = componentTypes.map(typeName => {
                try {
                    const data = getComponentData(world, entityId, typeName);
                    return { type: typeName, data: data || {} };
                } catch {
                    return { type: typeName, data: {} };
                }
            });
            return { entityId, name, parentId, children, components };
        }

        function getEntityName(world, entityId) {
            const sdk = window.__esSdk;
            if (sdk) {
                try {
                    const nameDef = sdk.getComponent('Name');
                    if (nameDef) {
                        const nameData = world.tryGet(entityId, nameDef);
                        if (nameData && nameData.value) return String(nameData.value);
                    }
                } catch {}
            }
            return 'Entity ' + entityId;
        }

        function getComponentTypes(world, entityId) {
            try {
                if (world.getComponentTypes) {
                    const types = world.getComponentTypes(entityId);
                    return types.map(t => String(t));
                }
            } catch {}
            return [];
        }

        function getEntityParentId(world, sdk, entityId) {
            if (!sdk) return null;
            try {
                const parent = world.tryGet(entityId, sdk.Parent);
                if (parent && parent.entity !== undefined && parent.entity !== 0) return Number(parent.entity);
            } catch {}
            return null;
        }

        function getEntityChildren(world, sdk, entityId) {
            if (!sdk) return [];
            try {
                const children = world.tryGet(entityId, sdk.Children);
                if (children && children.entities) {
                    const arr = children.entities;
                    const result = [];
                    for (let i = 0; i < arr.length; i++) result.push(Number(arr[i]));
                    return result;
                }
            } catch {}
            return [];
        }

        function serializeValue(val) {
            if (val === null || val === undefined) return val;
            if (typeof val === 'number' || typeof val === 'boolean' || typeof val === 'string') return val;
            if (Array.isArray(val)) return val.map(serializeValue);
            if (typeof val === 'object') {
                const out = {};
                for (const k of Object.keys(val)) {
                    const v = val[k];
                    if (typeof v === 'function') continue;
                    out[k] = serializeValue(v);
                }
                return out;
            }
            return String(val);
        }

        function serializeBuiltinComponent(data, compDef) {
            if (!compDef || !compDef._default) return serializeValue(data);
            const out = {};
            for (const key of Object.keys(compDef._default)) {
                try { out[key] = serializeValue(data[key]); } catch {}
            }
            return out;
        }

        function getComponentData(world, entityId, typeName) {
            const sdk = window.__esSdk;
            if (!sdk) return {};
            try {
                const compDef = sdk.getComponent(typeName);
                if (!compDef) return {};
                const data = world.tryGet(entityId, compDef);
                if (!data) return {};
                return compDef._builtin ? serializeBuiltinComponent(data, compDef) : serializeValue(data);
            } catch { return {}; }
        }

        function setEntityProperty(entityId, component, property, value) {
            if (!gameApp) return;
            const sdk = window.__esSdk;
            if (!sdk) return;
            const world = gameApp.world;
            try {
                const compDef = sdk.getComponent(component);
                if (!compDef) return;
                const current = world.tryGet(entityId, compDef);
                if (!current) return;

                if (compDef._builtin) {
                    const snapshot = serializeBuiltinComponent(current, compDef);
                    snapshot[property] = value;
                    world.insert(entityId, compDef, snapshot);
                } else {
                    current[property] = value;
                }
            } catch (e) {
                _origWarn.call(console, 'setEntityProperty failed:', e);
            }
        }

        function updateLoading(message) {
            loading.textContent = message;
        }

        function showError(msg, err) {
            loading.style.display = 'none';
            errorDiv.style.display = 'block';
            let detail = msg;
            if (err && err.stack) {
                detail += '\n\n' + err.stack;
            }
            errorDiv.textContent = detail;
            console.error('Preview Error:', msg, err || '');
        }

        function setupCanvas() {
            const canvas = document.getElementById('canvas');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            return canvas;
        }

        function getCanvasViewportSize() {
            const canvas = document.getElementById('canvas');
            return { width: canvas.width, height: canvas.height };
        }

        const SPINE_WASM_MAP = {
            '3.8': '/wasm/spine38.js',
            '4.1': '/wasm/spine41.js',
            '4.2': '/wasm/spine42.js',
        };

        function loadUmdScript(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = () => { resolve(); script.remove(); };
                script.onerror = () => { reject(new Error('Failed to load ' + url)); script.remove(); };
                document.head.appendChild(script);
            });
        }

        function fetchWithRetry(url, options = {}, maxRetries = 3) {
            let attempt = 0;
            async function tryFetch() {
                try {
                    const resp = await fetch(url, options);
                    if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
                    return resp;
                } catch (err) {
                    attempt++;
                    if (attempt >= maxRetries) throw err;
                    await new Promise(r => setTimeout(r, 500 * attempt));
                    return tryFetch();
                }
            }
            return tryFetch();
        }

        function withTimeout(promise, ms, label) {
            return Promise.race([
                promise,
                new Promise((_, reject) =>
                    setTimeout(() => reject(new Error(`${label} timed out after ${ms / 1000}s`)), ms)
                ),
            ]);
        }

        async function loadPreview() {
            let step = 'init';
            try {
                step = 'load WASM module';
                updateLoading('Loading WASM module...');
                await fetchWithRetry('/wasm/esengine.js');
                const ModuleLoader = await withTimeout(import('/wasm/esengine.js'), 30000, 'WASM module import');
                const Module = await withTimeout(ModuleLoader.default(), 30000, 'WASM instantiation');

                step = 'load SDK';
                updateLoading('Loading SDK...');
                const sdk = await withTimeout(import('/sdk/index.js'), 30000, 'SDK import');
                window.__esSdk = sdk;

                let spinePlugin = null;
                let physicsPlugin = null;
                let config = {};
                try {
                    const configResp = await fetch('/.esengine/preview/config.json');
                    if (configResp.ok) {
                        config = await configResp.json();
                        const spineUrl = config.spineVersion && SPINE_WASM_MAP[config.spineVersion];
                        if (spineUrl) {
                            step = 'load Spine ' + config.spineVersion;
                            updateLoading('Loading Spine ' + config.spineVersion + '...');
                            await loadUmdScript(spineUrl);
                            const { SpinePlugin } = await import('esengine/spine');
                            spinePlugin = new SpinePlugin(spineUrl, window.ESSpineModule);
                        }
                    }
                } catch (e) {
                    console.warn('Spine module load skipped:', e);
                }

                if (config.enablePhysics) {
                    try {
                        step = 'load Physics';
                        updateLoading('Loading Physics...');
                        await loadUmdScript('/wasm/physics.js');
                        physicsPlugin = new sdk.PhysicsPlugin('/wasm/physics.js', {
                            gravity: { x: config.physicsGravityX ?? 0, y: config.physicsGravityY ?? -9.81 },
                            fixedTimestep: config.physicsFixedTimestep ?? 1 / 60,
                            subStepCount: config.physicsSubStepCount ?? 4,
                        }, window.ESPhysicsModule);
                    } catch (e) {
                        console.warn('Physics module load skipped:', e);
                    }
                }

                try {
                    await import('/.esengine/preview/user-scripts.js');
                } catch (e) {
                    console.warn('User scripts load skipped:', e);
                }

                step = 'setup canvas';
                updateLoading('Loading scene...');
                setupCanvas();
                window.addEventListener('resize', () => setupCanvas());

                step = 'apply runtime config';
                if (config.maxDeltaTime !== undefined) sdk.RuntimeConfig.maxDeltaTime = config.maxDeltaTime;
                if (config.maxFixedSteps !== undefined) sdk.RuntimeConfig.maxFixedSteps = config.maxFixedSteps;
                if (config.textCanvasSize !== undefined) sdk.RuntimeConfig.textCanvasSize = config.textCanvasSize;
                if (config.defaultFontFamily !== undefined) sdk.RuntimeConfig.defaultFontFamily = config.defaultFontFamily;
                if (config.sceneTransitionDuration !== undefined) sdk.RuntimeConfig.sceneTransitionDuration = config.sceneTransitionDuration;
                if (config.sceneTransitionColor) {
                    const hex = config.sceneTransitionColor.replace('#', '');
                    sdk.RuntimeConfig.sceneTransitionColor = {
                        r: parseInt(hex.substring(0,2), 16) / 255,
                        g: parseInt(hex.substring(2,4), 16) / 255,
                        b: parseInt(hex.substring(4,6), 16) / 255,
                        a: 1
                    };
                }
                if (config.canvasScaleMode !== undefined) {
                    const modeMap = { FixedWidth: 0, FixedHeight: 1, Expand: 2, Shrink: 3, Match: 4 };
                    sdk.RuntimeConfig.canvasScaleMode = modeMap[config.canvasScaleMode] ?? 1;
                }
                if (config.canvasMatchWidthOrHeight !== undefined) sdk.RuntimeConfig.canvasMatchWidthOrHeight = config.canvasMatchWidthOrHeight;

                step = 'create app';
                const previewPlugin = new sdk.PreviewPlugin('/.esengine/preview/scene.json', '/');

                const app = sdk.createWebApp(Module, {
                    getViewportSize: getCanvasViewportSize
                });
                if (config.maxDeltaTime !== undefined) app.setMaxDeltaTime(config.maxDeltaTime);
                if (config.maxFixedSteps !== undefined) app.setMaxFixedSteps(config.maxFixedSteps);

                step = 'flushPendingSystems';
                sdk.flushPendingSystems(app);

                step = 'add plugins';
                if (spinePlugin) {
                    app.addPlugin(spinePlugin);
                }
                if (physicsPlugin) {
                    app.addPlugin(physicsPlugin);
                }
                app.addPlugin(previewPlugin);

                step = 'waitForReady (scene load)';
                await withTimeout(previewPlugin.waitForReady(), 30000, 'scene loading');

                if (app.physicsInitPromise) {
                    step = 'physics init';
                    await app.physicsInitPromise;
                }

                step = 'app.run';
                loading.style.display = 'none';
                app.run();

                gameApp = app;
                sendToEditor('ready', {});
                reportStats();
            } catch (err) {
                showError('[' + step + '] ' + (err.message || String(err)), err);
            }
        }

        window.addEventListener('error', (e) => {
            showError('[runtime error] ' + (e.message || String(e)), e.error);
            sendToEditor('error', { message: e.message || String(e), stack: e.error?.stack });
        });
        window.addEventListener('unhandledrejection', (e) => {
            const err = e.reason;
            showError('[unhandled rejection] ' + (err?.message || String(err)), err);
            sendToEditor('error', { message: err?.message || String(err), stack: err?.stack });
        });

        function connectLiveReload() {
            const sse = new EventSource('/sse-reload');
            sse.onmessage = () => location.reload();
            sse.onerror = () => {
                sse.close();
                setTimeout(connectLiveReload, 2000);
            };
        }

        loadPreview();
        connectLiveReload();
    </script>
</body>
</html>
