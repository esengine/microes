<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESEngine Preview</title>
    <script type="importmap">
    {
        "imports": {
            "esengine": "/sdk/index.js",
            "esengine/wasm": "/sdk/wasm.js",
            "esengine/spine": "/sdk/spine/index.js"
        }
    }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #1a1a2e; }
        #canvas { width: 100%; height: 100%; display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e0e0e0;
            font-family: system-ui, sans-serif;
            font-size: 14px;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-family: monospace;
            font-size: 13px;
            max-width: 80%;
            white-space: pre-wrap;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">Loading...</div>
    <div id="error"></div>

    <script type="module">
        const loading = document.getElementById('loading');
        const errorDiv = document.getElementById('error');

        function updateLoading(message) {
            loading.textContent = message;
        }

        function showError(msg, err) {
            loading.style.display = 'none';
            errorDiv.style.display = 'block';
            let detail = msg;
            if (err && err.stack) {
                detail += '\n\n' + err.stack;
            }
            errorDiv.textContent = detail;
            console.error('Preview Error:', msg, err || '');
        }

        function setupCanvas() {
            const canvas = document.getElementById('canvas');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            return canvas;
        }

        function getCanvasViewportSize() {
            const canvas = document.getElementById('canvas');
            return { width: canvas.width, height: canvas.height };
        }

        const SPINE_WASM_MAP = {
            '3.8': '/wasm/spine38.js',
            '4.1': '/wasm/spine41.js',
            '4.2': '/wasm/spine42.js',
        };

        function loadUmdScript(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = () => { resolve(); script.remove(); };
                script.onerror = () => { reject(new Error('Failed to load ' + url)); script.remove(); };
                document.head.appendChild(script);
            });
        }

        function fetchWithRetry(url, options = {}, maxRetries = 3) {
            let attempt = 0;
            async function tryFetch() {
                try {
                    const resp = await fetch(url, options);
                    if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
                    return resp;
                } catch (err) {
                    attempt++;
                    if (attempt >= maxRetries) throw err;
                    await new Promise(r => setTimeout(r, 500 * attempt));
                    return tryFetch();
                }
            }
            return tryFetch();
        }

        function withTimeout(promise, ms, label) {
            return Promise.race([
                promise,
                new Promise((_, reject) =>
                    setTimeout(() => reject(new Error(`${label} timed out after ${ms / 1000}s`)), ms)
                ),
            ]);
        }

        async function loadPreview() {
            let step = 'init';
            try {
                step = 'load WASM module';
                updateLoading('Loading WASM module...');
                await fetchWithRetry('/wasm/esengine.js');
                const ModuleLoader = await withTimeout(import('/wasm/esengine.js'), 30000, 'WASM module import');
                const Module = await withTimeout(ModuleLoader.default(), 30000, 'WASM instantiation');

                step = 'load SDK';
                updateLoading('Loading SDK...');
                const sdk = await withTimeout(import('/sdk/index.js'), 30000, 'SDK import');

                let spinePlugin = null;
                let physicsPlugin = null;
                let config = {};
                try {
                    const configResp = await fetch('/.esengine/preview/config.json');
                    if (configResp.ok) {
                        config = await configResp.json();
                        const spineUrl = config.spineVersion && SPINE_WASM_MAP[config.spineVersion];
                        if (spineUrl) {
                            step = 'load Spine ' + config.spineVersion;
                            updateLoading('Loading Spine ' + config.spineVersion + '...');
                            await loadUmdScript(spineUrl);
                            const { SpinePlugin } = await import('esengine/spine');
                            spinePlugin = new SpinePlugin(spineUrl, window.ESSpineModule);
                        }
                    }
                } catch (e) {
                    console.warn('Spine module load skipped:', e);
                }

                if (config.enablePhysics) {
                    try {
                        step = 'load Physics';
                        updateLoading('Loading Physics...');
                        await loadUmdScript('/wasm/physics.js');
                        physicsPlugin = new sdk.PhysicsPlugin('/wasm/physics.js', {
                            gravity: { x: config.physicsGravityX ?? 0, y: config.physicsGravityY ?? -9.81 },
                            fixedTimestep: config.physicsFixedTimestep ?? 1 / 60,
                            subStepCount: config.physicsSubStepCount ?? 4,
                        }, window.ESPhysicsModule);
                    } catch (e) {
                        console.warn('Physics module load skipped:', e);
                    }
                }

                try {
                    await import('/.esengine/preview/user-scripts.js');
                } catch (e) {
                    console.warn('User scripts load skipped:', e);
                }

                step = 'setup canvas';
                updateLoading('Loading scene...');
                setupCanvas();
                window.addEventListener('resize', () => setupCanvas());

                step = 'apply runtime config';
                if (config.maxDeltaTime !== undefined) sdk.RuntimeConfig.maxDeltaTime = config.maxDeltaTime;
                if (config.maxFixedSteps !== undefined) sdk.RuntimeConfig.maxFixedSteps = config.maxFixedSteps;
                if (config.textCanvasSize !== undefined) sdk.RuntimeConfig.textCanvasSize = config.textCanvasSize;
                if (config.defaultFontFamily !== undefined) sdk.RuntimeConfig.defaultFontFamily = config.defaultFontFamily;
                if (config.sceneTransitionDuration !== undefined) sdk.RuntimeConfig.sceneTransitionDuration = config.sceneTransitionDuration;
                if (config.sceneTransitionColor) {
                    const hex = config.sceneTransitionColor.replace('#', '');
                    sdk.RuntimeConfig.sceneTransitionColor = {
                        r: parseInt(hex.substring(0,2), 16) / 255,
                        g: parseInt(hex.substring(2,4), 16) / 255,
                        b: parseInt(hex.substring(4,6), 16) / 255,
                        a: 1
                    };
                }
                if (config.canvasScaleMode !== undefined) {
                    const modeMap = { FixedWidth: 0, FixedHeight: 1, Expand: 2, Shrink: 3, Match: 4 };
                    sdk.RuntimeConfig.canvasScaleMode = modeMap[config.canvasScaleMode] ?? 1;
                }
                if (config.canvasMatchWidthOrHeight !== undefined) sdk.RuntimeConfig.canvasMatchWidthOrHeight = config.canvasMatchWidthOrHeight;

                step = 'create app';
                const previewPlugin = new sdk.PreviewPlugin('/.esengine/preview/scene.json', '/');

                const app = sdk.createWebApp(Module, {
                    getViewportSize: getCanvasViewportSize
                });
                if (config.maxDeltaTime !== undefined) app.setMaxDeltaTime(config.maxDeltaTime);
                if (config.maxFixedSteps !== undefined) app.setMaxFixedSteps(config.maxFixedSteps);

                step = 'flushPendingSystems';
                sdk.flushPendingSystems(app);

                step = 'add plugins';
                if (spinePlugin) {
                    app.addPlugin(spinePlugin);
                }
                if (physicsPlugin) {
                    app.addPlugin(physicsPlugin);
                }
                app.addPlugin(previewPlugin);

                step = 'waitForReady (scene load)';
                await withTimeout(previewPlugin.waitForReady(), 30000, 'scene loading');

                if (app.physicsInitPromise) {
                    step = 'physics init';
                    await app.physicsInitPromise;
                }

                step = 'app.run';
                loading.style.display = 'none';
                app.run();
            } catch (err) {
                showError('[' + step + '] ' + (err.message || String(err)), err);
            }
        }

        window.addEventListener('error', (e) => {
            showError('[runtime error] ' + (e.message || String(e)), e.error);
        });
        window.addEventListener('unhandledrejection', (e) => {
            const err = e.reason;
            showError('[unhandled rejection] ' + (err?.message || String(err)), err);
        });

        function connectLiveReload() {
            const sse = new EventSource('/sse-reload');
            sse.onmessage = () => location.reload();
            sse.onerror = () => {
                sse.close();
                setTimeout(connectLiveReload, 2000);
            };
        }

        loadPreview();
        connectLiveReload();
    </script>
</body>
</html>
